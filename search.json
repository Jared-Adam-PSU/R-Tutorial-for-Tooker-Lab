[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "One code to rule them all (┛ಠ_ಠ)┛彡O",
    "section": "",
    "text": "Welcome to an introductory R course for natural scientists"
  },
  {
    "objectID": "index.html#one-code-to-rule-them-all",
    "href": "index.html#one-code-to-rule-them-all",
    "title": "One code to rule them all (┛ಠ_ಠ)┛彡O",
    "section": "One Code To Rule Them All",
    "text": "One Code To Rule Them All\nThis page was originally built to act as an introduction to R and R studio. What it has become is that, plus a little extra. This page will be updated as new information/ lessons are requested. The link will not change, so no trouble.\nWe suggest starting from the beginning (even if you have used R before) and working through each section. When appropriate, previous sections will be referenced, sometimes linked, and we encourage you to use previous sections as when needed. Along with this, there are snippets of code which we encourage you to give a burn and copy each into your script.\nIf you have any suggestions or concerns, please email me at Jared.Adam@psu.edu.\n\nWhat this course will cover:\n\n\nPart 1: The Reasoning\n\nIntroduction: What is programming and what is R?\nR as a tool: How can we use R?\n\n\n\nPart 2: The Beginnings\n\nStarting a project: Importing data\nBasic functionality: Logic and shortcuts\nSeveral methods for calling different variables Calling data with operators\nGetting fancy widdit: What are functions, packages, and how can we use them?\nCoding etiquette: How to write simple and reproducible code\n\n\n\nPart 3: Buckle up\n\nData wrangling: Data wrangling with base R and other important packages"
  },
  {
    "objectID": "a_introduction.html#what-is-programming",
    "href": "a_introduction.html#what-is-programming",
    "title": "1  Introduction",
    "section": "1.1 What is programming?",
    "text": "1.1 What is programming?\n\nProgramming\nComputer programming is the process of writing code to facilitate actions in a computer, application, or software program, and instructs them on how to perform.\nEach ‘type’ of programming comes with it’s own language. A programming language is a vocabulary and set of grammatical rules for instructing a computer or computing device to perform specific tasks. Examples of programming languages include, but are not limited to , C, C++, Java, Python, and of course, R.\nThe purpose of programming is to find a sequence of instructions that will automate the performance of a task on a computer.\n\n\nWhat is R?\nAt it’s root, R is a language and environment for statistical computing and graphic building. R provides a variety of statistical (linear and nonlinear modeling, classical statistical tests, time series analysis, classification, etc.) and graphical techniques (Base R, ggplot, etc.).\nThis software excels in its ease of producing publication-ready high-quality plots, use of mathematical symbols, implementation of equations and formulas, and much more. Along with this, R is also a free, open-source software available on a wide variety of platforms, including both Windows and MacOS."
  },
  {
    "objectID": "a_introduction.html#getting-started-with-r",
    "href": "a_introduction.html#getting-started-with-r",
    "title": "1  Introduction",
    "section": "1.2 Getting started with R",
    "text": "1.2 Getting started with R\n\nDownloading R\nHow to download R, by Garrett Grolemund\n\n\nR vs RStudio\nR the application is installed on your computer and uses your personal computer resources to process R programming languages.\nRStudio integrates with R as an IDE (Integrated Development Environment) to provide further functionality. To reiterate, RStudio acts as a housing of sorts to allow for the functionality and script writing of R. Think of saving photos to iCloud. Without a device, your photos would be free-floating and rather inaccessible. BUT, with a device (housing), you are able to access these photos. RStudio acts similarly with R in that it provides an environment to use the software. There are other text editors and IDEs that are available, but we recommend starting with RStudio. RStudio helps you use the version of R on your computer, but it does not come with it’s own version of R."
  },
  {
    "objectID": "a_introduction.html#the-big-four",
    "href": "a_introduction.html#the-big-four",
    "title": "1  Introduction",
    "section": "1.3 The big four",
    "text": "1.3 The big four\n\nComponents of RStudio\n\n\n\nA screenshot of my RStudio\n\n\n\nRStudio is divided into four panes\n\nThe Script (top-left)\nThe R Console (bottom-left)\nYou Global Environment (top-right)\nYour Files/Plots/Packages/Help/Viewer (bottom-right)\n\n\n\nThe Script\nThe section is where your written code will go. Whenever you are giving R commands to complete, this text will be entered in the script.\nAlong with this, the Script is where any open R files will be housed. This allows you to navigate between scripts with ease.\n\n\n\nA screenshot of my Script\n\n\n\n\nThe R Console\nThis section is where your outputs will be printed. Whenever you run a line in the script, the console will produce an output, or an error message if the line was unable to be run. As you can see in the picture below, the console’s output is both the line I ran, paired with the respective output.\n\n\n\nA screenshot of my Conolse. This is what an my ran script output looks like.\n\n\n\n\n1.3.0.1 The Global Environment\nThis pane is where any of your imported or created objects will go. These could include, but are not limited to, data sets, functions, vectors, values, etc. If you wish to view your full data set, you can click on the the object. If you wish to view the the column and row names, but not view the full object, you can select the blue and white arrow on the left-hand side of the object name.\n\n\n\nGlobal Environment\n\n\n\n\nYour Files/Plots/Packages/Help/Viewer\nThis pane of RStudio is where a lot of information can be found. You can navigate your computers files, view the plots you’ve developed, install packages, and find helpful information and examples within an easy-to-use search bar.\n\n\n\nA screenshot of my Files and such"
  },
  {
    "objectID": "b_RasATool.html#excel-vs.-r-and-why-we-should-care",
    "href": "b_RasATool.html#excel-vs.-r-and-why-we-should-care",
    "title": "2  R as a tool",
    "section": "2.1 Excel vs. R and why we should care",
    "text": "2.1 Excel vs. R and why we should care\n\nExcel vs R\nWhen choosing between R and Excel, it is important to understand how both solutions can get you the results you need. However, one can make it an easy, reputable, convenient process, whereas the other can make it an extremely frustrating, time-consuming process prone to human errors.\nWhen opening Excel and applying data manipulation techniques to your data, are you easily able to tell what manipulations have been made without clicking on the column or cells? If you were to share these Excel sheets with colleagues are they easily able to replicate your analyses without you telling them where to click or which formulas were applied?\nWith R all of these are possible. You automatically have all the code visible and in front of you in the form of scripts. Reading and understanding the code is possible because of its easy-to-use, easy-to-read syntax which allows you to track what the code is doing without having to be concerned about any hidden functions or modifications happening in the background.\nWhen we consider our programming methods, we must strive for two goals: simple and reproducible. R makes both of these goals achievable.\n\nLet’s keep talking about this\nI want to inform you of something. This is entirely objective and bias-free (as if that is even possible).\nLet’s talk excel data sheets for a moment. Excel has some great features. The most flexible of these is the cell. An excel cell can be extremely flexible as they can store various data types (numeric, logical, and characters).\nThis is great! We can store our data here in a nice and organized manner and scroll through and view it all with relative ease.\nNot so fast. Lettuce think about a data set with 5,000 or 20,000, or 100,000, or 500,000, or 1,000,000 rows and 100+ columns. Now. Imagine scrolling through all of this looking for errors. Or double checking formulas written within new columns. Imagine saving this file over and over upon each rendition. What were to happen if an error was missed after formula was run and you continued to work and save new files? This could mean big trouble when it came time for a real analysis. Personally, that sounds like a nightmare.\n\n\n\n\n\nNow that I got that off my chest. Let’s chat about R. Within R are some great options for viewing our data. We can look in our environment. We can call certain base R functions (See functions section here) to view different sections.\nHere are some examples of these functions.\nThe structure (str) to view the nature of our data set.\n\nThe head function to view the first several rows of a data set.\n\nThe tail function to view the last several rows of our data set.\n\nThe colnames function to view the names of our columns.\n\nAs we are starting to see, when compared to Excel with examples of only viewing data, R is beginning to appear more versatile. We will continue to build on the capabilities of R in future sections and work through functions, etiquette, data wrangling, plotting, and much more."
  },
  {
    "objectID": "c_NewProj.html#starting-a-new-project",
    "href": "c_NewProj.html#starting-a-new-project",
    "title": "\n3  Starting a project\n",
    "section": "\n3.1 Starting a new project",
    "text": "3.1 Starting a new project\nTo begin, we must first open a new project.\n\nTo open a new project, you first select the RStudio app on your computer. Unless immediately prompted, select New Project under the File tab.\n\n\n\n\n\n\nNext you will be prompted select which Directory type. Select New Directory.\n\n\n\n\n\n\nNext, in the Project Type screen, you will select New Project.\n\n\n\n\n\n\nOnce selected, you will be prompted to name the Directory. Make this name unique and choose where you would like it to be saved."
  },
  {
    "objectID": "c_NewProj.html#r-compatible-data-sets",
    "href": "c_NewProj.html#r-compatible-data-sets",
    "title": "\n3  Starting a project\n",
    "section": "\n3.2 R-compatible data sets",
    "text": "3.2 R-compatible data sets\nWhen importing a data set from excel into R, the file type must be a .csv, rather than the typical .xlsx.\nFor further instruction on preparing an R-ready .csv, please see the link below.\nBuilding an R-friendly .csv"
  },
  {
    "objectID": "c_NewProj.html#how-to-get-data-into-r",
    "href": "c_NewProj.html#how-to-get-data-into-r",
    "title": "\n3  Starting a project\n",
    "section": "\n3.3 How to get data into R",
    "text": "3.3 How to get data into R\nImporting data\nWorking directory\nYour working directory is where you will have R pull data sheets from. There are two common ways of doing this.\nThe first step is to determine where R currently thinks our working directory is. To do this, we use the getwd function.\n\ngetwd()\n\n#output:\"C:/Users/jsada/OneDrive - The Pennsylvania State University/Documents\"\n\nAs you can see, the output shows my computer pathway, or source, of where R will be obtaining files.\nIf we wish to change this, we have two options.\nFirst, we will use the setwd package. Within the parentheses of this function, we will write out the desired pathway. Let’s say I wish to be more specific than just the Documents folder.\n\nsetwd(\"C:/Users/jsada/OneDrive - The Pennsylvania State University/Documents/Research/R/Intern Tutorial/Book\")\n\nThe second method for setting your working directory is done through the Session menu at the top. You will then hover over Set Working Directory and then select Choose Directory… From here, you will navigate to the folder you wish to pull data from.\n\n\nSetting my working directory\n\nNow that we have our working directory set, we can take a look into the folder.\nTo see how many files are in my directory, I will use the length function.\n\nlength(list.files())\n#output: 24\n\nTo see the first five files within my directory, I will use the head function.\n\nhead(list.files())\n#output:\n\n#[1] \"_book\"         \"_quarto.yml\"   \"Book.Rproj\"    \"cover.png\"    \n#[5] \"directory.png\" \"Glossary.qmd\" \n\nThe last command we will run to investigate our working directory is the %in% operator. We will use this operator to see if there is specific file within our directory. This operator will provide us with a logical out (TRUE or FALSE). When calling a specific object, we must use either half, or full parentheses.\n\n'Book.Rproj' %in% list.files()\n\n#output: TRUE\n\nGithub\nIn this book, I will not cover using the Github platform for data storage. If you wish to explore this further, please see the linked tutorial below.\nA Github tutorial by Callum Arnold"
  },
  {
    "objectID": "c_NewProj.html#types-of-data",
    "href": "c_NewProj.html#types-of-data",
    "title": "\n3  Starting a project\n",
    "section": "\n3.4 Types of data",
    "text": "3.4 Types of data\nNow that we have our data set imported into R, we can begin looking our data. The first step is gaining an understanding of the type of data we have. Within R, there are 5 main types of data. These include:\n\n\n\n\n\n\nData type\nExample\n\n\n\nnumeric\n(10.5,55,680)\n\n\ninteger\n(1L, 55L, 100L, where the letter “L” declares this an integer)\n\n\ncomplex\n(9+3i, where “i” is the imaginary part)\n\n\ncharacter\n(Also known as strings - “k”, “bugsRcool”, “11.5”, “etc.”)\n\n\nlogical\n(TRUE and FALSE)\n\n\n\nWhen it comes to data manipulations, statistical tests, model building, and developing plots, it is incredibly important that our data are classified as the correct data type. To determine this for single variables or values, we use the class function.\nCopy these examples into your script to try this function out.\n\n# numeric \nx &lt;- 10\nclass(x)\n\n# integer\nx &lt;- 10L\nclass(x)\n\n# complex\nx &lt;- 9i + 3\nclass(x)\n\n#character/string\nX &lt;- \"Boy howdy, this is rivetting stuff\"\nclass(x)\n\n# logical \nx &lt;- TRUE\nclass(x)"
  },
  {
    "objectID": "d_functionality.html#shortcuts-arithmetic-commands-logic-and-other-helpful-tools",
    "href": "d_functionality.html#shortcuts-arithmetic-commands-logic-and-other-helpful-tools",
    "title": "4  Basic functionality",
    "section": "4.1 Shortcuts, arithmetic commands, logic, and other helpful tools",
    "text": "4.1 Shortcuts, arithmetic commands, logic, and other helpful tools\n\nShortcuts\n\nRun\n\n\n\nTask\nWindows & Linux\nMac\n\n\n\n\nRun\nCtrl + Enter\nCmd + Return\n\n\n\n\n\nShortcuts for editing\n\n\n\nTask\nWindows & Linux\nMac\n\n\n\n\nCopy\nCtrl + C\nCmd + C\n\n\nPaste\nCtrl + V\nCmd + V\n\n\nUndo\nCtrl + Z\nCmd + Z\n\n\nRedo\nCtrl + Shift + Z\nCmd + Shift + Z\n\n\nSelect All\nCtrl + A\nCmd + A\n\n\nIndent\nTab\nTab\n\n\nOutdent\nShift + Tab\nShift + Tab\n\n\nInsert pipe operator\nCmd + Shift + M\nCmd + Shift + M\n\n\n\n\n\n\nArithmetic operators\n\n\n\nTask\nOperator\nExample\n\n\n\n\nAddition\n+\nx + y\n\n\nSubstraction\n-\nx - y\n\n\nMultiplication\n*\nx * y\n\n\nDivision\n/\nx / y\n\n\nExponent\n^\nx ^ y\n\n\n\n\n\nLogic commands\n\n\n\nTask\nOperator\nExample\n\n\n\n\nEqual\n==\nx == y\n\n\nNot equal\n!=\nx != y\n\n\nGreater than\n&gt;\nx &gt; y\n\n\nLess than\n&lt;\nx &lt; y\n\n\nGreater than or equal to\n&gt;=\nx &gt;= y\n\n\nLess than or equal to\n&lt;=\nx &lt;= y\n\n\n\n\n\nOther important operators\n\n\n\n\n\n\n\n\nTask\nOperator\nExample\n\n\n\n\nCall for the help menu for the respective function\n?\n?mean\n\n\nAssigning a name or value\n&lt;-\nName &lt;- \"Chop\"\n\n\nTo access one variable in a data set\n$\nDataSet$IWantThisColumn\n\n\nSearching or calling exact characters\n\"\"\n\"Chop Spring\"\n\n\nConcatenate (c), combines arguments, both numbers or words, into a vector\nc()\nName &lt;- c(\"Jared\", \"Daniel\", \"Chop\") Numbers &lt;- c(1,2,3)\n\n\nAnother form of concatenation used when writing long scripts of code which span multiple lines\n+\nThis line + this line too"
  },
  {
    "objectID": "e_CallingVariables.html#background-of-the-operators",
    "href": "e_CallingVariables.html#background-of-the-operators",
    "title": "\n5  Several methods for calling different variables\n",
    "section": "\n5.1 Background of the operators",
    "text": "5.1 Background of the operators\nWhen calling specific variable, list, or object in R, there are three main ways. These include the $ operator, the [] (bracket), and the %&gt;% (pipe) operator. These operators work in similar ways in that they allow you to access specific pieces of your data frame.\nIn this section we will investigate all three.\nThe dollar sign: $\n\nThis operator is used in R to access the list of a data frame. You can use this operator to access variables, add values or objects, update (e.g., change a class), and delete variables from a data frame.\nLet’s start by creating a data frame.\n\nscore &lt;- 1:4 #score column with values of 1-4\n\ninsect &lt;- c('wasp', 'beetle', 'ant', 'TrueBug') #insect column with a list of names \n\nfield &lt;- c('corn', 'beans', 'corn', 'beans') #field column with a list of names\n\nAvg_Weight_mg &lt;- c(2, 7, 0.5, 3) #assigning weight values to each insect\n\nSample_DF &lt;- data.frame(score, insect, field, Avg_Weight_mg) #using the data.frame function to create a date frame with the columns I established above \n\nprint(Sample_DF) #using the print function to view my new data frame\n\n  score  insect field Avg_Weight_mg\n1     1    wasp  corn           2.0\n2     2  beetle beans           7.0\n3     3     ant  corn           0.5\n4     4 TrueBug beans           3.0\n\n\nNow that we have our data frame, let’s use the $ operator to investigate our data.\nFirst, let’s say we want to look at the insect column. The $ operator here pulls out the just the values of this column. Notice, to use this, we need to specify a source. The source here is ‘Sample_DF’. Try this operator out to see which variations of column names will, and will not provide you with an output.\n\nSample_DF$insect #show me the insect column within Sample_DF\n\n[1] \"wasp\"    \"beetle\"  \"ant\"     \"TrueBug\"\n\n\nSo, now we can see the functionality of this operator as a means of viewing data. Let’s now investigate adding a new column to this existing Sample_DF.\nIn this example, we will be adding a column to specify whether the insect was an adult, or not. We will do this by adding our new object name following our source, Sample_DF, and then specifying the values of this column. Remember, we need to have a source data frame when we use this operator.\n\nSample_DF$adult &lt;- c('yes', 'no', 'no', 'yes') #naming a new column IN Sample_DF with the values within c()\n\nprint(Sample_DF) #printing this updated df\n\n  score  insect field Avg_Weight_mg adult\n1     1    wasp  corn           2.0   yes\n2     2  beetle beans           7.0    no\n3     3     ant  corn           0.5    no\n4     4 TrueBug beans           3.0   yes\n\n\nWe can now see our new column was added to the right-hand side of the existing data frame.\nLettuce look at one more example of how we can use this operator. Here, we will be changing the class of an object within Sample_DF.\nIn this example, I want to change the class of score from integer, to numeric. Notice, I have to call the data source in the beginning to tell R I do not want to create a new object, I only want to change my existing data frame. Next, I need to specify the source for the function, as.numeric.\n\nSample_DF$score &lt;- as.numeric(Sample_DF$score) #within my df, in the score column, change the class to numerical \n\nIf you wanted to create a new object with this change, we can simply change the name of the object.\nWe can do this, like so.\n\nNew_DF &lt;- as.numeric(Sample_DF$score) #within a new df, in the score column, change the class to numerical\n\nprint(New_DF) #show me the new df\n\n[1] 1 2 3 4\n\n\nNotice here, the new object only houses the values from the score column.\nSingle dimension square bois: []\n\nBrackets [], in R, work similarly to that of the dollar sign ($). Brackets are especially useful when we want to extract single elements from an object. Let’s start by creating a simple, single dimension vector.\n\n#ceating a numeric vector\nVector_One &lt;- c(1,2,3,4,5,6)\n\nNow, let’s pull some stoof out. In this example, I am going to pull out several individual values from the vector we just created.\n\nVector_One[1] #extracting the first value of the data set \n\n[1] 1\n\nVector_One[3] #extracting the third value of the data set \n\n[1] 3\n\n\nNow that we have extracted individual values, let’s pull several out at once. Notice that the syntax has changed a bit. We now must tell R that we want to combine the three values into one output. This is done by adding, c(1,2,3), within our brackets\n\nVector_One[c(1,2,3)] #extracting the first, second, and third value of the data set\n\n[1] 1 2 3\n\n\nThe next step is to have R to pull values out based on a command. In the following example, we will use some of the logic commands we covered earlier.\nLet’s say I want to see all of the values in this data set that are above the number 3.\n\nVector_One[Vector_One &gt; 3] #extracting values greater than 3\n\n[1] 4 5 6\n\n\nWe can repeat this step with any logical operator we would like.\nFor example.\n\nVector_One[Vector_One &gt;= 2] #extracting values greater than or equal to 2\n\nVector_One[Vector_One != 2] #extracting values that do not equal 2\n\nMultiple dimension square bois: []\n\nNow that we can see how to use the brackets when looking for single objects (like a simple vector), let’s start to look at the use of brackets with an increase in dimensions. Multiple dimensions come into play when we are investigating a full data frame or matrix. In this section, we will be looking at the Sample_DF data frame we created above.\nWithin the bracket are assigned values. By this, I mean, depending on the location of the number within the bracket, the location that information is pulled from will change. The assigned locations are [row, column]\nFor example, if we were to run [1,2], our output would be the value in the first row and second column.\nIn this example, we will pull out the values from the first row, and second column.\n\nSample_DF[1,2] #extracting values from row 1 and column 2\n\n[1] \"wasp\"\n\n\nNext, let’s investigate what happens when we leave one of the ‘values’ blank.\n\nSample_DF[,2] #extracting values from all rows and the second column\n\n[1] \"wasp\"    \"beetle\"  \"ant\"     \"TrueBug\"\n\n\nWhat we see here is that R gave us the values from all rows, but just the second column.\nWe can use the same method if we want to view information from all one row, but all columns.\n\nSample_DF[1,] #extracting values from row 1, and all columns \n\n  score insect field Avg_Weight_mg adult\n1     1   wasp  corn             2   yes\n\n\nIn the next example, we will investigate how to exclude information. Let’s say we want to view the whole data frame except for the values of row 1. This is done by using, -1, in the row value of the brackets.\nIn this example, I am telling R to exclude all values of row 1 from the output.\n\nSample_DF[-1,] #extracting all values, except for row 1 information\n\n  score  insect field Avg_Weight_mg adult\n2     2  beetle beans           7.0    no\n3     3     ant  corn           0.5    no\n4     4 TrueBug beans           3.0   yes\n\n\nIn our last example of the bracket, we will extract information from a specified column, but all rows. To do this, we will continue to leave the row value blank, but add in the exact name of the column we seek to view.\nLet’s take a look at the ‘insect’ column.\n\nSample_DF[, \"insect\"] #extracting values from all rows, but just the insect column\n\n[1] \"wasp\"    \"beetle\"  \"ant\"     \"TrueBug\"\n\n\nOur output shows us all of the values within the insect column.\nLast but not least, the pipe: %&gt;%\n\nFor the sake of not working too far ahead, I will not include many examples here. In the data wrangling section, I will be exclusively using the pipe operator. Please see that section for working examples of the pipe operator.\nSO. We have investigated, and worked through, the dollar sign operator and brackets for pulling out specific elements. These methods are certainly effective, but as we start to work through larger data sets of raw data, there may be many changes we need to apply.\nTo accomplish this, we could write out a new command line for each iteration, OR, we can ‘pipe’ several commands into one operation. This processing of piping links all of our changes to one command, allowing for efficiency and easy error-tracking. To reiterate, this task is the chaining of arguments into one command.\nThis operator, the pipe %&gt;%, is arguably one of the most important operators in data wrangling and processing.\nRory Spanton, with Toward Data Science, explains this process well, “To visualize this process, imagine a factory with different machines placed along a conveyor belt. Each machine is a function that performs a stage of our analysis, like filtering or transforming data. The pipe therefore works like a conveyor belt, transporting the output of one machine to another for further processing.”\nHere I will write out two examples. Within these examples, I will be creating functions and then running them sequentially both with, and without the pipe operator. We will cover writing functions in the future.\n\n# starting with creating three separate functions \n\n# a function to add two values\nadd &lt;- function(x,y) {\n  return(x+y)\n}\n\n# a function to multiply two values\nmul &lt;- function(x,y) {\n  return(x*y)\n}\n\n# a function to divide two values\ndiv &lt;- function(x,y) {\n  return(x/y)\n}\n\nNow that we have our functions created, let’s put them to work in the long form.\n\n# I am now calling each function sequentially \n\nresult_1 &lt;- add(2,4) # applying my add function to two values (x,y)\n\nresult_2 &lt;- mul(result_1, 5) # applying my mul function to the results from the add function (x) and a new value of 5 (y)\n\nresult_3 &lt;- div(result_2, 6) # applying my div function to the results from the mul function (x) and a new value of 6 (y)\n\nprint(result_3)\n\n[1] 5\n\n\nAs we can see, this method is effective. But, where it falters, is that we must save each iteration and then input that object name into the next function. While this example is simple, we can imagine how with an increase in the complexity of our functions and sequential manipulations, this can become an overwhelming method.\nLet’s now look at the same sequence of functions, but this time using the pipe operator.\nFirst, we will need to load in the dplyr package to use the pipe operator.\n\nlibrary(dplyr) #loading the dplyr package\n\n\n# piping my three functions together \nresults &lt;- add(2,4) %&gt;% # adding 2 and 4 with the add function \n  mul(5) %&gt;% # chaining the results from add into the mul function\n  div(6) #chaining the results from the mul function into the div function\n\nprint(results) #printing the results \n\n[1] 5\n\n\nWe got the same output!  As we can see, this method is both cleaner (regarding your environment and saving objects over and over) and safer (with regard to errors) than the sequential example.\nThe results, explained\nContinuing to follow Rory’s brilliant synthesis of this operator, I will use their example here. Let’s think of %&gt;% as the word ‘then’.\nLet’s now write out the same piping example.\n\n\nThe results from this chain will be named “results”,\n\nI will be adding the numbers 2 and 4 together, THEN\nI will multiply the results from the addition by 5, THEN\nI will divide the results from the multiplication by 6\n\n\n\nAs we can see, this operator acts as a link in the chain which holds the whole argument together, allowing it to act as one command. The pipe operator is an excellent addition your coding repertoire when you would like to eliminate the saving of multiple objects with each iterative change, lower the risk of an error occurring within the multiple changes, and allow for a cleaner, more palatable, R script."
  },
  {
    "objectID": "f_fancy.html#functions-packages-and-all-that-jazz",
    "href": "f_fancy.html#functions-packages-and-all-that-jazz",
    "title": "\n6  Getting fancy widdit\n",
    "section": "\n6.1 Functions, packages, and all that jazz",
    "text": "6.1 Functions, packages, and all that jazz\nWhat is a function?\nA function in R is an object containing multiple interrelated statements that are run together in a predefined order every time the function is called. What this means, is that within every function, there are set of instructions to be followed in their respective order to complete a desired task.\nFor example, let’s say we want to find the mean value of a desired set of numbers.\n\n(1+2+3+4+5+6) / 6\n\n[1] 3.5\n\n\nThis is an effective method for acquiring the average of a small set of numbers that are not saved in R. But, what if they were saved?\nIn this example, we create a vector named ‘Mean_Example’ with the previous six numbers. Rather than adding them manually, we use the sum function to automatically add the values. We then set this sum to be divided by six, which is the total number of values.\n\nMean_Example &lt;- c(1,2,3,4,5,6)\n\nsum(Mean_Example)/6\n\n[1] 3.5\n\n\nNow, let’s crank this up a notch. What do we do if we have a large data set and want to calculate the mean of a column? First, I created a data set named ‘bugs’ with three columns: spiders, beetles, and wasps. Then, using the rnorm function, I set the number of values per column with a default mean of 0 and standard deviation of 1. The purpose of this fake data set is just so we have something to work with with an expected mean.\nOnce this data set is created, we can test out the mean function on one of the columns. Within the mean function, I tell R to take the mean of the spider column FROM the ‘bugs’ data set we created. The ‘$’ symbol tells R where to look within an existing data set.\n\nbugs &lt;- data.frame(\n  spiders = rnorm(200),\n  beetles = rnorm(250),\n  wasps = rnorm(1000)\n)\n\nmean(bugs$spiders)\n\n[1] -0.03954701\n\n#Remember, our default mean was 0\n\nWhat is a package?\nWhile R has many built in functions (e.g., mean), some of the most useful functions do not come pre-installed. When this is the case, they are provided to us in well made, neatly packed downloadable objects called packages. In essence, the creator of the package has nestled a bunch of things to make your programming life easier into a little folder you can download, and use, at your leisure. An R package can bundle together useful function, help files, and data sets. Typically, a package will have a list of functions all related to the same task or set of tasks.\nLet’s take a look at the ggplot2 package. The purpose of this package is on the grammar of graphics; the idea that you can build every graph from the same components: a data set, a coordinate system, and geoms-visual marks that represent data points. Functions, such as ggplot, that reside within this package are all designed for the ease of figure development.\nLet’s take a look at how to download a package, starting with ggplot2.\nTo download a package, we must use the install.packages function, and place the desired package name in “quotation marks” within the function parenthesis. Once downloaded, we must then ‘call’ the function into our system. Using the library function, we tell R to load this package into our current project. We only need to install the package once, but we must ‘call’ it in every time we restart Rstudio. (To run this code, you must remove the # symbol from install.packages.\n\n#install.packages(\"ggplot2\")\n\nlibrary(ggplot2)\n\nPackages with data\nNow that we can investigated installing and downloading a package for the use of functions, we will now explore available data sets on R. There are many available data sets within R that we can download and practice programming, but for this tutorial we will work with Palmer Penguins. It is wise to download this now, because we will revisit this data set in future sections.\nTake notice of how I use quotation marks around the package name when using the function install.packages, but not when I load the package into my session with the library function.\n\n#install.packages(\"palmerpenguins\")\n\nlibrary(palmerpenguins)"
  },
  {
    "objectID": "g_etiquette.html#how-to-write-code-that-is-clean-clear-and-reproducible",
    "href": "g_etiquette.html#how-to-write-code-that-is-clean-clear-and-reproducible",
    "title": "\n7  Coding etiquette\n",
    "section": "\n7.1 How to write code that is clean, clear, and reproducible",
    "text": "7.1 How to write code that is clean, clear, and reproducible\nNaming new objects in R\nFirst, and foremost, we should investigate how to name new objects within R. There are two methods to complete this task. These include the equals sign, =, and the carrot jawn, &lt;-.\nFor example, the output of these lines will be identical.\n\ndata = c(1,2,3) #new object with equals sign\n\ndata &lt;- c(1,2,3) #new object with carrot jawn\n\nWhile these are the same, what we recommend is using the carrot method (&lt;-). This is because many functions require the use of = within code (this will come up in the future). For this reason, we find it best to utilize the carrot whenever you change the name of an object, or add a new object.\nIt is important to remember that you can change the time of an object whenever you want. This is especially helpful when making changes to our data set. With each iterative change, we can change the name of the object. This will allow us to backtrack to the pevious change in the event we make a mistake.\nStyle\nCoding, like any other writing type, is dependent upon clear and consistent style. As the tidyverse style guide so eloquently put it, “Good coding style is like correct punctuation: you can manage without it, butitsuremakesthingseasiertoread.” Here, we can clearly see how a simple phrase becomes exponentially more challenging to read and understand. The same goes for coding.\nIt is important to remember that R cannot handle spaces between words. Because of this, we must be creative in how we name things. It is a good idea to follow the BigCamelCase naming method. Let’s start by naming a vector.\n\n#GOOD\nMyNewVector &lt;- c(1,2,3,4,5,6)\n\n#BAD \nmynewvector &lt;- c(7,8,9,10,11,12)\n\nWhile in this example it is fairly easy to read both, we see how the name following the BigCamelCase format is easier to follow.\nLet’s look at another example of naming, this time getting more specific with our vector name.\n\n#GOOD\nSlugDensityData_Spring2023 &lt;- c(1,3,5,7)\n\n#BAD\nslugdensitydataspring2023 &lt;- c(2,4,6,8)\n\nI incorporated an underscore in the first name to make it even more distinct. We can clearly see now with increasing complexity of our names, the first is much easier to read.\nAnnotations\nWhen taking notes in a lecture, do you think it wise to take poorly written and hard to understand notes? Or, would we rather take clear, concise, and methodical notes to ensure we can return to them and understand exactly what the lecture was about? If you choose the former, then please, continue reading.\nAnnotation, like note taking, is very important within our code. We must be able to return to each line and know exactly what we did and why we did it. Along with this, if we wish to share this code with anyone, they too must be able to understand the methodology without needing you by their side. The habit of good code annotation is one that should be adopted immediately and practiced throughout the duration of your programming days.\nLet’s look at some examples of both good, and bad annotations.\n\n#GOOD\n##\n#I am creating a vector to practice running different functions \n\nPracticeVector &lt;- c(11,3,4,5,6,7)\n\n#Trying out the mean function here\nmean(PracticeVector)\n#This works. I will leave this code here to reference in the future\n##\n\n\n#BAD\npracticevector &lt;- c(11,2,3,4,5,11,2)\nmean(practicevector)\n\nWhile these examples are very simple in their nature, we can imagine how scrolling through 500+ lines of un-annotated code can be a nightmare. Along with this, to reiterate my naming point, we can see how with poor naming practices and a lack of annotation, the bad example is doubly hard to follow.\nAlong with annotating what you are doing, it can also be helpful to write out your thought process for an action. Let’s say you are writing code for a project on a Friday, and since you are great at managing your workload, you plan to not work this weekend. When Monday rolls around, you open your R script up and have completely forgotten why you were running a specific test or structuring your code a specific way.\nWith proper annotation, this hiccup can be avoided.\nLet’s take a look at some examples.\n\n#GOOD\n## \n#I am trying to create a fake data set to practice some functions on \n#Not to be used for analyses, simply for me\n\nbugs &lt;- data.frame( #naming this 'bugs' and using the data.frame function to build this\n  spiders = rnorm(200), #naming this column 'spiders' and using the rnorm function. This function builds a column with a default mean of 0 and a standard deviation of 1. This column will have 200 values.\n  beetles = rnorm(250), #Same as above, but with 250 values\n  wasps = rnorm(1000) #Same as above, but with 1000 values\n)\n##\n\nIn this example, I clearly noted what I was doing and why I was doing it. For my sake, I can return to this easily. If someone else was to come upon this, they too would be able to understand what my process was.\n\n#BAD\nnotbugs &lt;- data.frame(\n  clover = rnorm(200),\n  shrubberies = rnorm(200),\n  elderberry = rnorm(2000)\n)\n\nIn this example, it is unclear what the purpose of this data set is. Along with that, if someone is not familiar with this script, they may find it very challenging to follow."
  },
  {
    "objectID": "h_wrangling.html#cleaning-our-data-in-r",
    "href": "h_wrangling.html#cleaning-our-data-in-r",
    "title": "\n8  Data wrangling\n",
    "section": "\n8.1 Cleaning our data in R",
    "text": "8.1 Cleaning our data in R\nR &gt; excel\nBefore we begin wrangling our data set, let’s quickly discuss why cleaning data in R is important. First and foremost, my Excel file never needs to change. Along with this, I only need to save it once. No saving a new copy every time I make a new column or want to write a formula.\nIn this section, we will go over some important packages and key functions that will aid in the transition from Excel-based data wrangling to exclusively R-based data wrangling. SO, without further ado, lettuce begin.\nWhat we use to wrangle\nWhen we wrangle our data sets, there is one ‘umbrella’ package I find to be the most versatile. This is tidyverse. Tidyverse houses many useful packages for data manipulation, but in this section I will only be referring to one. This package is dplyr. While I rely on this package a lot, I also use functions pre-installed in Base R while wrangling.\nPlease see the wrangling cheat sheets here."
  },
  {
    "objectID": "h_wrangling.html#dplyr-examples",
    "href": "h_wrangling.html#dplyr-examples",
    "title": "\n8  Data wrangling\n",
    "section": "\n8.2 dplyr Examples",
    "text": "8.2 dplyr Examples\nLet’s start by installing the needed packages. Remember to remove the # symbol to install these packages. We will also call in our Palmer Penguins data set that you downloaded earlier.\n\n#install.packages(\"dplyr\")\nlibrary(dplyr)\n\n#install.packages(\"tidyverse\")\nlibrary(tidyverse)\n\nlibrary(palmerpenguins)\ndata(package = 'palmerpenguins') #investigating the pieces of this data set. How many data sets are there? \n\nNAs in R\nBefore we begin, we must first check for missing values. R does not love when NAs get thrown into the mix, especially when running numerical commands, like the mean function.\nTo resolve any missing values, we must first determine if there are any NAs, and where they may be.\nFirst, we will look to see IF and WHERE potential NAs are in our data set. We will do this by using the which function, followed by the is.na function within our penguins data set. What these two functions do together is which locates all of the columns where NAs are present, based on the is.na function. If we wanted to find all of the columns where there were no NAs, we could simply change is.na to !is.na.\nIn this example, my command is to determine where the NAs are. Using the arr.ind = TRUE command, I am telling R to show me exactly where they are. In this example we are using penguins_raw. This is the only section that will use the raw data set in the example.\n\nwhich(is.na(penguins_raw), arr.ind = TRUE) #checking for NA locations in penguins_raw\n\nNow that we see there are NAs riddled throughout, we will name a new object (using the same name), but omitting all NAs.\nIn this example, I am using the na.omit function to remove all NAs from our penguin data set. I am also naming this new object (penguins_raw again for ease).\n\npenguins_raw &lt;-\n  na.omit(penguins_raw) #I must add this because there are NAs within this data set and these functions will not work otherwise \n\nselect()\nLet’s start by selecting for only the columns we are interested in. This can be useful when removing variables we are not currently interested in. Remember, at any manipulation, you can save the changes as a new object which will maintain the integrity of the original if you must back track for whatever reason.\nIn this example, we use the select function to choose which columns we want to look at. Notice, we are back to using penguins!\n\n# select()\npenguins %&gt;% #From the penguins data set\n  select(species, bill_length_mm, year) # selecting columns species, bill_length, and      year \n\n# A tibble: 344 × 3\n   species bill_length_mm  year\n   &lt;fct&gt;            &lt;dbl&gt; &lt;int&gt;\n 1 Adelie            39.1  2007\n 2 Adelie            39.5  2007\n 3 Adelie            40.3  2007\n 4 Adelie            NA    2007\n 5 Adelie            36.7  2007\n 6 Adelie            39.3  2007\n 7 Adelie            38.9  2007\n 8 Adelie            39.2  2007\n 9 Adelie            34.1  2007\n10 Adelie            42    2007\n# … with 334 more rows\n\n\nNow that we have selected for certain columns, let’s say we want to view everything except for one or several columns. Instead of typing out every column we want, we can simple type out the one(s) we don’t.\nIn this example, I tell R to remove the sex column using the select function again.\n\n# select()\npenguins %&gt;% #From the penguins data set\n  select(-sex)# selecting all columns except for sex\n\n# A tibble: 344 × 7\n   species island    bill_length_mm bill_depth_mm flipper_length…¹ body_…²  year\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;            &lt;int&gt;   &lt;int&gt; &lt;int&gt;\n 1 Adelie  Torgersen           39.1          18.7              181    3750  2007\n 2 Adelie  Torgersen           39.5          17.4              186    3800  2007\n 3 Adelie  Torgersen           40.3          18                195    3250  2007\n 4 Adelie  Torgersen           NA            NA                 NA      NA  2007\n 5 Adelie  Torgersen           36.7          19.3              193    3450  2007\n 6 Adelie  Torgersen           39.3          20.6              190    3650  2007\n 7 Adelie  Torgersen           38.9          17.8              181    3625  2007\n 8 Adelie  Torgersen           39.2          19.6              195    4675  2007\n 9 Adelie  Torgersen           34.1          18.1              193    3475  2007\n10 Adelie  Torgersen           42            20.2              190    4250  2007\n# … with 334 more rows, and abbreviated variable names ¹​flipper_length_mm,\n#   ²​body_mass_g\n\n\nWithin the select function, you can also look for items based on their spelling. This can be especially helpful if you suspect there to be a spelling error somewhere if your data set. In this example, we will search our data set for any variable name that starts with the letter ‘b’.\n\n# select()\npenguins %&gt;% #From the penguins data set\n  select(starts_with('b')) # selecting columns that start with 'b' and using starts_with\n\n# A tibble: 344 × 3\n   bill_length_mm bill_depth_mm body_mass_g\n            &lt;dbl&gt;         &lt;dbl&gt;       &lt;int&gt;\n 1           39.1          18.7        3750\n 2           39.5          17.4        3800\n 3           40.3          18          3250\n 4           NA            NA            NA\n 5           36.7          19.3        3450\n 6           39.3          20.6        3650\n 7           38.9          17.8        3625\n 8           39.2          19.6        4675\n 9           34.1          18.1        3475\n10           42            20.2        4250\n# … with 334 more rows\n\n\nrename()\nNow that we have viewed and selected for different columns and such, we manipulate our data set further. We will start by renaming some columns. Notice with rename, there are two methods you can use. One without quotation marks, and one with.\nIn this example, using the rename function, I am changing ‘species’ to ‘Species and ’year’ to ‘Year’.\n\n# rename()\npenguins %&gt;%\n  select(species, bill_length_mm, year) %&gt;% #selecting the columns I want to look at\n  rename( #rename function. notice here the two methods of changing names\n    Species = species, #changing species to Species without quotes\n    \"Year\" = year #changing year to Year with quotes\n  )\n\n# A tibble: 344 × 3\n   Species bill_length_mm  Year\n   &lt;fct&gt;            &lt;dbl&gt; &lt;int&gt;\n 1 Adelie            39.1  2007\n 2 Adelie            39.5  2007\n 3 Adelie            40.3  2007\n 4 Adelie            NA    2007\n 5 Adelie            36.7  2007\n 6 Adelie            39.3  2007\n 7 Adelie            38.9  2007\n 8 Adelie            39.2  2007\n 9 Adelie            34.1  2007\n10 Adelie            42    2007\n# … with 334 more rows\n\n\narrange()\nlet’s arrange some stuff this is equivalent to sort!\nOne of the first steps we take in Excel is the sorting of our data sets. Whether that be the sorting of plots, or dates, or anything; we start by sorting. The same is possible in R. We do this using the arrange function.\nIn this example, we will be sorting by bill length in an increasing order (smallest to largest). Notice here that R will default to the order of small-large with the arrange function.\n\n# select() and arrange()\npenguins %&gt;%\n  select(species, bill_length_mm, year) %&gt;% \n  arrange(bill_length_mm) #I want to look at bill length in an increasing order from      smallest to largest \n\n# A tibble: 344 × 3\n   species bill_length_mm  year\n   &lt;fct&gt;            &lt;dbl&gt; &lt;int&gt;\n 1 Adelie            32.1  2009\n 2 Adelie            33.1  2008\n 3 Adelie            33.5  2008\n 4 Adelie            34    2008\n 5 Adelie            34.1  2007\n 6 Adelie            34.4  2007\n 7 Adelie            34.5  2008\n 8 Adelie            34.6  2007\n 9 Adelie            34.6  2008\n10 Adelie            35    2008\n# … with 334 more rows\n\n\nIn this example, we will be sorting by bill length in a decreasing order (largest to smallest). Notice here, we need the arrange function to tell R we will be changing the order. Once that command is established, we can further command the order.\nIn this example, I use the arrange function, followed by the desc function (descending), commanding the order of bill length to go from big to small values.\n\n# select(), arrange(), and desc()\npenguins %&gt;%\n  select(species, bill_length_mm, year) %&gt;% \n  arrange(desc(bill_length_mm)) #using the desc() function to command the order from      largest to smallest \n\n# A tibble: 344 × 3\n   species   bill_length_mm  year\n   &lt;fct&gt;              &lt;dbl&gt; &lt;int&gt;\n 1 Gentoo              59.6  2007\n 2 Chinstrap           58    2007\n 3 Gentoo              55.9  2009\n 4 Chinstrap           55.8  2009\n 5 Gentoo              55.1  2009\n 6 Gentoo              54.3  2008\n 7 Chinstrap           54.2  2008\n 8 Chinstrap           53.5  2008\n 9 Gentoo              53.4  2009\n10 Chinstrap           52.8  2008\n# … with 334 more rows\n\n\nNow, let’s say we want to see bill length in the same descending order, but we want to order this by year. This is done with a very simple addition to our arrange() section. To accomplish this, we add the year variable first (remembering the the default for arrange is small-large) followed by the bill length command (which is the same as the previous example.)\n\n# select() and arrange()\npenguins %&gt;%\n  select(species, bill_length_mm, year) %&gt;% \n  arrange(year, desc(bill_length_mm)) #year and bill separated by a comma\n\n# A tibble: 344 × 3\n   species   bill_length_mm  year\n   &lt;fct&gt;              &lt;dbl&gt; &lt;int&gt;\n 1 Gentoo              59.6  2007\n 2 Chinstrap           58    2007\n 3 Chinstrap           52.7  2007\n 4 Chinstrap           52    2007\n 5 Chinstrap           52    2007\n 6 Chinstrap           51.7  2007\n 7 Chinstrap           51.3  2007\n 8 Chinstrap           51.3  2007\n 9 Chinstrap           51.3  2007\n10 Chinstrap           50.6  2007\n# … with 334 more rows\n\n\nfilter()\nWithin R, we also have the ability to subset out data sets and pull out rows with specific values. Let’s say I only want to look at data from 2007. To accomplish this, we will use the filter function.\nIn this example, we will be adding the filter function as well as recall our knowledge of (operators) within R.\n\n# select() and filter()\npenguins %&gt;%\n  select(species, bill_length_mm, bill_depth_mm, year) %&gt;% \n  filter(year == 2007) #using the '==' operator to show everything with the year 2007\n\n# A tibble: 110 × 4\n   species bill_length_mm bill_depth_mm  year\n   &lt;fct&gt;            &lt;dbl&gt;         &lt;dbl&gt; &lt;int&gt;\n 1 Adelie            39.1          18.7  2007\n 2 Adelie            39.5          17.4  2007\n 3 Adelie            40.3          18    2007\n 4 Adelie            NA            NA    2007\n 5 Adelie            36.7          19.3  2007\n 6 Adelie            39.3          20.6  2007\n 7 Adelie            38.9          17.8  2007\n 8 Adelie            39.2          19.6  2007\n 9 Adelie            34.1          18.1  2007\n10 Adelie            42            20.2  2007\n# … with 100 more rows\n\n\nWhat if I want to see which penguins have bill lengths that are higher than the average length, but only from 2007? This can be accomplished by, again, adding an operator, but also calling another function. We will command R further with mean function from base R. Notice I am separating each line in the filter function with a comma. This allows me to add multiple commands within the same function.\n\n# select(), filter(), and mean()\n\npenguins %&gt;%\n  select(species, bill_length_mm, year) %&gt;% \n  filter(\n    year == 2007,#using the '==' operator to show everything with the year 2007\n    bill_length_mm &gt; mean(bill_length_mm), # using '&gt;' to view every row where the bill length is greater than the avg bill length \n  ) \n\n# A tibble: 0 × 3\n# … with 3 variables: species &lt;fct&gt;, bill_length_mm &lt;dbl&gt;, year &lt;int&gt;\n\n\nLet’s say we are interested in manipulating our data set by species.\nI want to know how many species I have to further filter this set. To accomplish this, I will use the the count function to view how many species I have and their associated values within the data set.\n\n# count()\npenguins %&gt;% \n  count(species)\n\n# A tibble: 3 × 2\n  species       n\n  &lt;fct&gt;     &lt;int&gt;\n1 Adelie      152\n2 Chinstrap    68\n3 Gentoo      124\n\n\nIt appears there are three species within my data set. For one reason or another, I want to filter out Adelie from further interpretations. To do this, I will add another line below the bill length filter.\nThis new line says when species equals Chinstrap OR Gentoo, keep them in the data set.\n\n# select() and filter()\npenguins %&gt;%\n  select(species, bill_length_mm, year) %&gt;% \n  filter(\n    year == 2007,#using the '==' operator to show everything with the year 2007\n    bill_length_mm &gt; mean(bill_length_mm),# using '&gt;' to view every row where the bill length is greater than the avg bill length\n    species == \"Chinstrap\" | species == \"Gentoo\" # look in species and pull out chinstrap and gentoo. | allows to command two species, similar to 'or'\n  ) \n\n# A tibble: 0 × 3\n# … with 3 variables: species &lt;fct&gt;, bill_length_mm &lt;dbl&gt;, year &lt;int&gt;\n\n\nAnother way to accomplish the same task is to tell R which values to exclude, rather than include. This is done by using the ‘does not equal’ operator to command R to return every species value that is not Adelie.\n\n# select () and filter()\npenguins %&gt;%\n  select(species, bill_length_mm, year) %&gt;% \n  filter(\n    year == 2007,#using the '==' operator to show everything with the year 2007\n    bill_length_mm &gt; mean(bill_length_mm),# using '&gt;' to view every row where the bill length is greater than the avg bill length \n    species != \"Adelie\" #does not equal operator\n  ) \n\n# A tibble: 0 × 3\n# … with 3 variables: species &lt;fct&gt;, bill_length_mm &lt;dbl&gt;, year &lt;int&gt;\n\n#the output is the same!\n\nNow that we only the data we want to see, let’s create some new columns and row values. Let’s say we want to add a new column combining species and year and a new column with the rounded values of bill length. We will be using the mutate function here. Along with this, we then want to rearrange our data set for viewing purposes of our new variables. This will be done with the select function.\nIn this example, I have created the column ‘sp_year’ which will contain both species and year, but keep their respective values separated by a dash. I then created a new column of the rounded bill length values using the round function. Notice with these new columns, the first step is to name the new column and then command R what to put in. Lastly, using the select function, I command R to order this data set as follows.\n\n# select(), mutate(), select()\npenguins %&gt;%\n  select(species, bill_length_mm, year) %&gt;% \n  mutate( #mutate()\n    sp_year = paste(species, \"-\", year), #adding a new column named 'sp_year' and pasting the species column and year column with a dash between them. \n    rn_bill_length_mm = round(bill_length_mm) #creating a column of rounded bill lengths \n  ) %&gt;% \n  select(species, year, sp_year, bill_length_mm, rn_bill_length_mm) #placing these new columns an order I would like \n\n# A tibble: 344 × 5\n   species  year sp_year       bill_length_mm rn_bill_length_mm\n   &lt;fct&gt;   &lt;int&gt; &lt;chr&gt;                  &lt;dbl&gt;             &lt;dbl&gt;\n 1 Adelie   2007 Adelie - 2007           39.1                39\n 2 Adelie   2007 Adelie - 2007           39.5                40\n 3 Adelie   2007 Adelie - 2007           40.3                40\n 4 Adelie   2007 Adelie - 2007           NA                  NA\n 5 Adelie   2007 Adelie - 2007           36.7                37\n 6 Adelie   2007 Adelie - 2007           39.3                39\n 7 Adelie   2007 Adelie - 2007           38.9                39\n 8 Adelie   2007 Adelie - 2007           39.2                39\n 9 Adelie   2007 Adelie - 2007           34.1                34\n10 Adelie   2007 Adelie - 2007           42                  42\n# … with 334 more rows\n\n\nsummarize()\nNow that we are confident in our wrangling, we can investigate some summary statistics.\nFirst, let’s look at the means and standard deviations of both bill length and depth. This will be done by name new columns and then using either the mean function or sd function to produce a desired output.\n\n# summarize ()\npenguins %&gt;% \n  summarize( #summarize to run summary stats \n  bill_length_mean = mean(bill_length_mm), #new column with mean value of bill length\n  bill_length_sd = sd(bill_length_mm), #new column with standard deviation value of bill length\n  bill_depth_mean = mean(bill_depth_mm), #new column with mean value of bill depth\n  bill_depth_sd = sd(bill_depth_mm) #new column with standard deviation value of bill depth\n  )\n\n# A tibble: 1 × 4\n  bill_length_mean bill_length_sd bill_depth_mean bill_depth_sd\n             &lt;dbl&gt;          &lt;dbl&gt;           &lt;dbl&gt;         &lt;dbl&gt;\n1               NA             NA              NA            NA\n\n\nThe last output was informative, but lets look a little deeper. I now want to group these new values by species. Using the group_by function, we can tell R to group our data set by one, or more variables.\nIn this example, I am telling R to group_by species, and then provide me with the means and standard deviations of bill length and depth.\n\n# group_by() and summarize()\npenguins %&gt;% \n  group_by(species) %&gt;% #grouping by one column, species \n  summarize( #summarize to run summary stats \n    bill_length_mean = mean(bill_length_mm), #new column with mean value of bill length\n    bill_length_sd = sd(bill_length_mm), #new column with standard deviation value of bill length\n    bill_depth_mean = mean(bill_depth_mm), #new column with mean value of bill depth\n    bill_depth_sd = sd(bill_depth_mm) #new column with standard deviation value of bill depth\n  )\n\n# A tibble: 3 × 5\n  species   bill_length_mean bill_length_sd bill_depth_mean bill_depth_sd\n  &lt;fct&gt;                &lt;dbl&gt;          &lt;dbl&gt;           &lt;dbl&gt;         &lt;dbl&gt;\n1 Adelie                NA            NA               NA           NA   \n2 Chinstrap             48.8           3.34            18.4          1.14\n3 Gentoo                NA            NA               NA           NA   \n\n\nFollowing the trend of the last example, let’s further group our data set. I want to now see these same values but by species AND year. Using the group_by function again, we can accomplish this.\nIn this example, the only change is I added ‘, year’ into my group_by function.\n\n# group_by() and summarize()\npenguins %&gt;% \n  group_by(species, year) %&gt;% #grouping by two columns, species and year \n  summarize( #summarize to run summary stats \n    bill_length_mean = mean(bill_length_mm), #new column with mean value of bill length\n    bill_length_sd = sd(bill_length_mm), #new column with standard deviation value of bill length\n    bill_depth_mean = mean(bill_depth_mm), #new column with mean value of bill depth\n    bill_depth_sd = sd(bill_depth_mm) #new column with standard deviation value of bill depth\n  )\n\n`summarise()` has grouped output by 'species'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 9 × 6\n# Groups:   species [3]\n  species    year bill_length_mean bill_length_sd bill_depth_mean bill_depth_sd\n  &lt;fct&gt;     &lt;int&gt;            &lt;dbl&gt;          &lt;dbl&gt;           &lt;dbl&gt;         &lt;dbl&gt;\n1 Adelie     2007             NA            NA               NA          NA    \n2 Adelie     2008             38.6           2.98            18.2         1.09 \n3 Adelie     2009             39.0           2.56            18.1         1.24 \n4 Chinstrap  2007             48.7           3.47            18.5         1.00 \n5 Chinstrap  2008             48.7           3.62            18.4         1.40 \n6 Chinstrap  2009             49.1           3.10            18.3         1.10 \n7 Gentoo     2007             47.0           3.27            14.7         0.908\n8 Gentoo     2008             46.9           2.64            14.9         0.985\n9 Gentoo     2009             NA            NA               NA          NA"
  },
  {
    "objectID": "h_wrangling.html#practice-on-your-own",
    "href": "h_wrangling.html#practice-on-your-own",
    "title": "\n8  Data wrangling\n",
    "section": "\n8.3 Practice on your own",
    "text": "8.3 Practice on your own\nFirst, take the penguins_raw data set and get it as close to the cleaned data set, penguins, as you can. Use the methods we went over in this section, and apply changes where needed. Hint, the is.na section is already done. Once complete, continue to the next practice assignment.\nNow that we have worked through some examples with Palmer Penguins, let’s try and work through a data set of our own.\nAttached here is a Slug data set.\nRemember, you will need to import this file into R in the correct format!\nYour task is to [1] input it into R, [2] investigate the variables and classes of these variables, [3] produce an output using each of the functions we just covered, [4] and at least one example where you use select, rename, arrange, filter, mutate, and group_by in the same command line. In part 3, for each change to the data set, save the changed data set as a new object. For part 4, save this object as, ‘Final_Changes’. If you conduct more than one iteration of part 4, add the associated number at the end of each name. For example, Final_Changes_1, Final_Changes_2, etc."
  },
  {
    "objectID": "j_ggplotHW.html#recreate-these-plots-to-the-best-of-your-ability",
    "href": "j_ggplotHW.html#recreate-these-plots-to-the-best-of-your-ability",
    "title": "\n9  Testing your skills: ggplot\n",
    "section": "Recreate these plots to the best of your ability",
    "text": "Recreate these plots to the best of your ability\nIn this section, we will be using the mtcars data set. Let’s start by reading in ggplot and the mtcars data set.\n\nlibrary(ggplot2)\ndata(\"mtcars\")\n\nFor more information about this data set, look in the help section.\n\n?mtcars()\n\nNow, let’s take a look a little closer at the data set. Which ‘class’ do these variables belong to? Are they numeric? Characters? Integers?\nThis knowledge is very impoartant when building your plots.\n\nView(mtcars)\nstr(mtcars)\n\nHints\nHere is an example of how to change the variable type inside of the ggplot lines and outside. Notice here, we are calling the am column with the $ operator.\n\nggplot(mtcars, aes(x = as.factor(am)))\nmtcars$am &lt;- as.factor(mtcars$am)\n\nYou may also need to search for ggplot format help on these. Please see the extra resources at the bottom of this page.\nPlot time\nGraph 1: geom_point\n\n\n\n\n\nGraph 2: geom_boxplot\n\n\n[1] \"0\" \"1\"\n\n\n\n\n\nMore to come!! 6/9/2023\nAdditional resources\nLecture notes\nBasic R graphics guide\nggplot online textbook"
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "10  Resources and cheat sheets",
    "section": "",
    "text": "Cheat sheet links\n(Data Table)\n(dplyr and tidyr)\n(ggplot)"
  },
  {
    "objectID": "Endearment.html#to-whom-it-may-concern",
    "href": "Endearment.html#to-whom-it-may-concern",
    "title": "11  Terms of endearment",
    "section": "To whom it may concern",
    "text": "To whom it may concern\nShout out to Daniel Bliss for listening to me think loud (and complain) during this process and also for being the first person to proof read.\nChief editor: Daniel D’Bliss\nEditor: Shea Tillotson\nGitHub troubelshooter: Callum Arnold"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "What is R?\n\nnd. “What is R?” The R Foundation. (link)\n\nRStudio vs r\n\nnd. “R and RStudio” BYU: Department of Statistics. (link)\n\nExcel vs r\n\nAbrahams, Amieroh. February 23,2023. “Why should I use R: The Excel R Data Wrangling comparison” jumping rivers. (link)\n\nStyle\n\nnd. “The tidyverse style guide” tidyverse. (link)\nnd. “Google’s R Style Guide” styleguide. (link)\nhttps://towardsdatascience.com/an-introduction-to-the-pipe-in-r-823090760d64 pipe"
  }
]