[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "One code to rule them all (┛ಠ_ಠ)┛彡O",
    "section": "",
    "text": "Welcome to an introductory R course for natural scientists\n\nWhat this course will cover:\n\n\nPart 1: The Reasoning\n\nIntroduction: What is programming and what is R?\nR as a tool: How can we use R?\n\n\n\nPart 2: The Beginnings\n\nStarting a project: Importing data\nBasic functionality: Logic and shortcuts\nGetting fancy widdit: What are functions, packages, and how can we use them?\nCoding etiquette: How to write simple and reproducible code\n\n\n\nPart 3: Buckle up\n\nData wrangling: Data wrangling with base R and other important packages"
  },
  {
    "objectID": "lesson01.html#getting-started-with-r",
    "href": "lesson01.html#getting-started-with-r",
    "title": "1  What is programming?",
    "section": "1.1 Getting started with R",
    "text": "1.1 Getting started with R\n\nDownloading R\nHow to download R, by Garrett Grolemund\n\n\nR vs RStudio\nR the application is installed on your computer and uses your personal computer resources to process R programming languages.\nRStudio integrates with R as an IDE (Integrated Development Environment) to provide further functionality. To reiterate, RStudio acts as a housing of sorts to allow for the functionality and script writing of R. Think of saving photos to iCloud. Without a device, your photos would be free-floating and rather inaccessible. BUT, with a device (housing), you are able to access these photos. RStudio acts similarly with R in that it provides an environment to use the software. There are other text editors and IDEs that are available, but we recommend starting with RStudio. RStudio helps you use the version of R on your computer, but it does not come with it’s own version of R."
  },
  {
    "objectID": "lesson01.html#the-big-four",
    "href": "lesson01.html#the-big-four",
    "title": "1  What is programming?",
    "section": "1.2 The big four",
    "text": "1.2 The big four\n\nComponents of RStudio\n\n\n\nA screenshot of my RStudio\n\n\n\nRStudio is divided into four panes\n\nThe Script (top-left)\nThe R Console (bottom-left)\nYou Global Environment (top-right)\nYour Files/Plots/Packages/Help/Viewer (bottom-right)\n\n\n\nThe Script\nThe section is where your written code will go. Whenever you are giving R commands to complete, this text will be entered in the script.\nAlong with this, the Script is where any open R files will be housed. This allows you to navigate between scripts with ease.\n\n\n\nA screenshot of my Script\n\n\n\n\nThe R Console\nThis section is where your outputs will be printed. Whenever you run a line in the script, the console will produce an output, or an error message if the line was unable to be run. As you can see in the picture below, the console’s output is both the line I ran, paired with the respective output.\n\n\n\nA screenshot of my Conolse\n\n\n\n\n1.2.0.1 The Global Environment\nThis pane is where any of your imported or created objects will go. These could include, but are not limited to, data sets, functions, vectors, values, etc. If you wish to view your full data set, you can click on the the object. If you wish to view the the column and row names, but not view the full object, you can select the blue and white arrow on the left-hand side of the object name.\n\n\n\nGlobal Environment\n\n\n\n\nYour Files/Plots/Packages/Help/Viewer\nThis pane of RStudio is where a lot of information can be found. You can navigate your computers files, view the plots you’ve developed, install packages, and find helpful information and examples within an easy-to-use search bar.\n\n\n\nA screenshot of my Files and such"
  },
  {
    "objectID": "lesson02.html",
    "href": "lesson02.html",
    "title": "2  Excel vs. R and why we should care",
    "section": "",
    "text": "#: R as a tool ### Excel vs R {.unnumbered} When choosing between R and Excel, it is important to understand how both solutions can get you the results you need. However, one can make it an easy, reputable, convenient process, whereas the other can make it an extremely frustrating, time-consuming process prone to human errors.\nWhen opening Excel and applying data manipulation techniques to your data, are you easily able to tell what manipulations have been made without clicking on the column or cells? If you were to share these Excel sheets with colleagues are they easily able to replicate your analyses without you telling them where to click or which formulas were applied?\nWith R all of these are possible. You automatically have all the code visible and in front of you in the form of scripts. Reading and understanding the code is possible because of its easy-to-use, easy-to-read syntax which allows you to track what the code is doing without having to be concerned about any hidden functions or modifications happening in the background.\nWhen we consider our programming methods, we must strive for two goals: simple and reproducible. R makes both of these goals achievable.\n\nLet’s keep talking about this\nI want to inform you of something. This is entirely objective and bias-free (as if that is even possible).\nLet’s talk excel data sheets for a moment. Excel has some great features. The most flexible of these is the cell. An excel cell can be extremely flexible as they can store various data types (numeric, logical, and characters).\nThis is great! We can store our data here in a nice and organized manner and scroll through and view it all with relative ease.\nNot so fast. Lettuce think about a data set with 5,000 or 20,000, or 100,000, or 500,000, or 1,000,000 rows and 100+ columns. Now. Imagine scrolling through all of this looking for errors. Or double checking formulas written within new columns. Imagine saving this file over and over upon each rendition. What were to happen if an error was missed after formula was run and you continued to work and save new files? This could mean big trouble when it came time for a real analysis. Personally, that sounds like a nightmare.\n\n\n\n\n\nNow that I got that off my chest. Let’s chat about R. Within R are some great options for viewing our data. We can look in our environment. We can call certain base R functions (See functions section here) to view different sections.\nHere are some examples of these functions.\nThe structure (str) to view the nature of our data set.\n\nThe head function to view the first several rows of a data set.\n\nThe tail function to view the last several rows of our data set.\n\nThe colnames function to view the names of our columns.\n\nAs we are starting to see, when compared to Excel with examples of only viewing data, R is beginning to appear more versatile. We will continue to build on the capabilities of R in future sections and work through functions, etiquette, data wrangling, plotting, and much more."
  },
  {
    "objectID": "lesson03.html#r-compatible-data-sets",
    "href": "lesson03.html#r-compatible-data-sets",
    "title": "3  Starting a new project",
    "section": "3.1 R-compatible data sets",
    "text": "3.1 R-compatible data sets\nWhen importing a data set from excel into R, the file type must be a .csv, rather than the typical .xlsx.\nFor further instruction on preparing an R-ready .csv, please see the link below.\nBuilding an R-friendly .csv"
  },
  {
    "objectID": "lesson03.html#how-to-get-data-into-r",
    "href": "lesson03.html#how-to-get-data-into-r",
    "title": "3  Starting a new project",
    "section": "3.2 How to get data into R",
    "text": "3.2 How to get data into R\n\nImporting data\n\nWorking directory\nYour working directory is where you will have R pull data sheets from. There are two common ways of doing this.\nThe first step is to determine where R currently thinks our working directory is. To do this, we use the getdw function.\n\ngetwd()\n\n#output:\"C:/Users/jsada/OneDrive - The Pennsylvania State University/Documents\"\n\nAs you can see, the output shows the pathway no my computer where R is looking for files. If we wish to change this, we have two options.\nFirst, we will use the setwd package. Within the parentheses of this function, we will write out the desired pathway. Let’s say I wish to be more specific than just the Documents folder.\n\nsetwd(\"C:/Users/jsada/OneDrive - The Pennsylvania State University/Documents/Research/R/Intern Tutorial/Book\")\n\nThe second method for setting your working directory is done through the Session menu at the top. You will then hover over Set Working Directory and then select Choose Directory… From here, you will navigate to the folder you wish to pull data from.\n Now that we have our working directory set, we can take a look into the folder.\nTo see how many files are in my directory, I will use the length function.\n\nlength(list.files())\n#output: 24\n\nTo see the first five files within my directory, I will use the head function.\n\nhead(list.files())\n#output:\n\n#[1] \"_book\"         \"_quarto.yml\"   \"Book.Rproj\"    \"cover.png\"    \n#[5] \"directory.png\" \"Glossary.qmd\" \n\nThe last command we will run to investigate our working directory is the %in% operator. We will use this operator to see if there is specific file within our directory. This operator will provide us with a logical out (TRUE or FALSE). When calling a specific object, we must use either half, or full parentheses.\n\n'Book.Rproj' %in% list.files()\n\n#output: TRUE\n\n\n\nGithub\nIn this book, I will not cover using the Github platform for data storage. If you wish to explore this further, please see the linked tutorial below.\nA Github tutorial by Callum Arnold"
  },
  {
    "objectID": "lesson03.html#types-of-data",
    "href": "lesson03.html#types-of-data",
    "title": "3  Starting a new project",
    "section": "3.3 Types of data",
    "text": "3.3 Types of data\nNow that we have our data set imported into R, we can begin looking our data. The first step is gaining an understanding of the type fo data we have. Within R, there are 5 main types of data. These include:\n\n\n\n\n\n\n\nData type\nExample\n\n\n\n\nnumeric\n(10.5,55,680)\n\n\ninteger\n(1L, 55L, 100L, where the letter “L” declares this an integer)\n\n\ncomplex\n(9+3i, where “i” is the imaginary part)\n\n\ncharacter\n(Also known as strings - “k”, “bugsRcool”, “11.5”, “etc.”)\n\n\nlogical\n(TRUE and FALSE)\n\n\n\nWhen it comes to data manipulations, statistical tests, model building, and developing plots, it is incredibly important that our data are classified as the correct data type. To determine this for single variables or values, we use the class function.\nCopy these examples into your script to try this function out.\n\n# numeric \nx &lt;- 10\nclass(x)\n\n# integer\nx &lt;- 10L\nclass(x)\n\n# complex\nx &lt;- 9i + 3\nclass(x)\n\n#character/string\nX &lt;- \"Boy howdy, this is rivetting stuff\"\nclass(x)\n\n# logical \nx &lt;- TRUE\nclass(x)"
  },
  {
    "objectID": "lesson04.html",
    "href": "lesson04.html",
    "title": "4  Shortcuts, arithmetic commands, logic, and other helpful tools",
    "section": "",
    "text": "#: Basic functionality ### Shortcuts {.unnumbered}\n\nRun\n\n\n\nTask\nWindows & Linux\nMac\n\n\n\n\nRun\nCtrl + Enter\nCmd + Return\n\n\n\n\n\nShortcuts for editing\n\n\n\nTask\nWindows & Linux\nMac\n\n\n\n\nCopy\nCtrl + C\nCmd + C\n\n\nPaste\nCtrl + V\nCmd + V\n\n\nUndo\nCtrl + Z\nCmd + Z\n\n\nRedo\nCtrl + Shift + Z\nCmd + Shift + Z\n\n\nSelect All\nCtrl + A\nCmd + A\n\n\nIndent\nTab\nTab\n\n\nOutdent\nShift + Tab\nShift + Tab\n\n\nInsert pipe operator\nCmd + Shift + M\nCmd + Shift + M\n\n\n\n\n\nArithmetic operators\n\n\n\nTask\nOperator\nExample\n\n\n\n\nAddition\n+\nx + y\n\n\nSubstraction\n-\nx - y\n\n\nMultiplication\n*\nx * y\n\n\nDivision\n/\nx / y\n\n\nExponent\n^\nx ^ y\n\n\n\n\n\nLogic commands\n\n\n\nTask\nOperator\nExample\n\n\n\n\nEqual\n==\nx == y\n\n\nNot equal\n!=\nx != y\n\n\nGreater than\n&gt;\nx &gt; y\n\n\nLess than\n&lt;\nx &lt; y\n\n\nGreater than or equal to\n&gt;=\nx &gt;= y\n\n\nLess than or equal to\n&lt;=\nx &lt;= y\n\n\n\n\n\nOther important operators\n\n\n\n\n\n\n\n\nTask\nOperator\nExample\n\n\n\n\nCall for the help menu for the respective function\n?\n?mean\n\n\nAssigning a name or value\n&lt;-\nName &lt;- \"Jared\"\n\n\nTo access one variable in a dataset\n$\nDataSet$IWantThisColumn\n\n\nSearching or calling exact characters\n\"\"\n\"Jared\"\n\n\nConcatenate (c), combines arguments, both numbers or words, into a vector\nc()\nName &lt;- c(\"Jared\", \"Daniel\", \"Tooker\") Numbers &lt;- c(1,2,3)\n\n\nAnother form of concatenation used when writing long scripts of code which span multiple lines\n+\nThis line + this line too"
  },
  {
    "objectID": "lesson05.html#functions-packages-and-all-that-jazz",
    "href": "lesson05.html#functions-packages-and-all-that-jazz",
    "title": "5  : Getting fancy widdit",
    "section": "5.1 Functions, packages, and all that jazz",
    "text": "5.1 Functions, packages, and all that jazz\n\nWhat is a function?\nA function in R is an object containing multiple interrelated statements that are run together in a predefined order every time the function is called. What this means, is that within every function, there are set of instructions to be followed in their respective order to complete a desired task.\nFor example, let’s say we want to find the mean value of a desired set of numbers.\n\n(1+2+3+4+5+6) / 6\n\n[1] 3.5\n\n\nThis is an effective method for acquiring the average of a small set of numbers that are not saved in R. But, what if they were saved?\nIn this example, we create a vector named ‘Mean_Example’ with the previous six numbers. Rather than adding them manually, we use the sum function to automatically add the values. We then set this sum to be divided by six, which is the total number of values.\n\nMean_Example &lt;- c(1,2,3,4,5,6)\n\nsum(Mean_Example)/6\n\n[1] 3.5\n\n\nNow, let’s crank this up a notch. What do we do if we have a large data sheet and want to calculate the mean of a column? First, I created a data set named ‘bugs’ with three columns: spiders, beetles, and wasps. Then, using the rnorm function, I set the number of values per column with a default mean of 0 and standard deviation of 1.\nOnce this data set is created, we can test out the mean function on one of the columns. Within the mean function, I tell R to take the mean of the spider column FROM the ‘bugs’ data set we created. The ‘$’ symbol tells R where to look within an existing data set.\n\nbugs &lt;- data.frame(\n  spiders = rnorm(200),\n  beetles = rnorm(250),\n  wasps = rnorm(1000)\n)\n\nmean(bugs$spiders)\n\n[1] -0.123828\n\n#Remember, our default mean was 0\n\n\n\nWhat is a package?\nWhile R has many built in functions (e.g., mean()), some of the most useful functions do not come pre-installed. When this is the case, they are provided to us in well made, neatly packed downloadable objects called packages. In essence, the creator of the package has nestled a bunch of things to make your prgramming life easiser into a little folder you can download, and use, at your leisure. An R package can bundle together useful function, help files, and data sets. Typically, a package will have a list of functions all related to the same task or set of tasks.\nLet’s take a look at the ggplot2 package. The purpose of this package is on the grammar of grpahics; the idea that you can build every graph from the same components: a data set, a coordinate system, and geoms-visual marks that represent data points. Functions, such as ggplot, that reside within this package are all designed for the ease of figure development.\nLet’s take a look at how to download a package, starting with ggplot2.\nTo download a package, we must use the install.packages function, and place the desired package name in “quotation marks” within the function parenthesis. Once downloaded, we must then ‘call’ the function into our system. Using the library function, we tell R to load this package into our current project. We only need to install the package once, but we must ‘call’ it in every time we restart Rstudio. (To run this code, you must remove the # symbol from install.packages())\n\n#install.packages(\"ggplot2\")\n\nlibrary(ggplot2)\n\n\n\nPackages with data\nNow that we can investigated installing and downloading a package for the use of functions, we will now explore available data sets on R. There are many available data sets within R that we can download and practice programming, but for this tutorial we will work with Palmer Penguins. It is wise to download this now, because we will revisit this data set in future sections.\n\n#install.packages(palmerpenguins)\n\nlibrary(palmerpenguins)"
  },
  {
    "objectID": "lesson06.html#how-to-write-code-that-is-clean-clear-and-reproducible",
    "href": "lesson06.html#how-to-write-code-that-is-clean-clear-and-reproducible",
    "title": "6  : Coding etiquette",
    "section": "6.1 How to write code that is clean, clear, and reproducible",
    "text": "6.1 How to write code that is clean, clear, and reproducible\n\nStyle\nCoding, like any other writing type, is dependent upon clear and consistent style. As the tidyverse style guide so eloquently put it, “Good coding style is like correct punctuation: you can manage without it, butitsuremakesthingseasiertoread.” Here, we can clearly see how a simple phrase becomes exponentially more challenging to read and understand. The same goes for coding.\nIt is important to remember that R cannot handle spaces between words. Because of this, we must be creative in how we name things. It is a good idea to follow the BigCamelCase naming method. Let’s start by naming a vector\n\n#GOOD\nMyNewVector &lt;-c(1,2,3,4,5,6)\n\n#BAD \nmynewvector &lt;- c(7,8,9,10,11,12)\n\nWhile in this example it is fairly easy to read both, we see how the name following the BigCamelCase format is easier to follow.\nLet’s look at another example of naming, this time getting more specific with our vector name.\n\n#GOOD\nSlugDensityData_Spring2023 &lt;- c(1,3,5,7)\n\n#BAD\nslugdensitydataspring2023 &lt;-c(2,4,6,8)\n\nI incorporated an underscore in the first name to make it even more distinct. We can clearly see now with increasing complexity of our names, the first is much easier to read.\n\n\nAnnotations\nWhen taking notes in a lecture, do you think it wise to take poorly written and hard to understand notes? Or, would we rather take clear, concise, and methodical notes to ensure we can return to them and understand exactly what the lecture was about? If you choose the former, then please, continue reading.\nAnnotation, like note taking, is very important within our code. We must be able to return to each line and know exactly what we did and why we did it. Along with this, if we wish to share this code with anyone, they too must be able to understand the methodology without needing you by their side. The habit of good code annotation is one that should be adopted immediately and practiced throughout the duration of your programming days.\nLet’s look at some examples of both good, and bad annotations.\n\n#GOOD\n##\n#I am creating a vector to practice running different functions \n\nPracticeVector &lt;- c(11,3,4,5,6,7)\n\n#Trying out the mean function here\nmean(PracticeVector)\n#This works. I will leave this code here to reference in the future\n##\n\n\n#BAD\npracticevector &lt;- c(11,2,3,4,5,11,2)\nmean(practicevector)\n\nWhile these examples are very simple in their nature, we can imagine how scrolling through 500+ lines of un-annotated code can be a nightmare. Along with this, to reiterate my naming point, we can see how with poor naming practices and a lack of annotation, the bad example is doubly hard to follow.\nAlong with annotating what you are doing, it can also be helpful to write out your thought process for an action. Let’s say you are writing code for a project on a Friday, and since you are great at managing your workload, you plan to not work this weekend. When Monday rolls around, you open your R script up and have completely forgotten why you were running a specific test or structuring your code a specific way.\nWith proper annotation, this hiccup can be avoided.\nLet’s take a look at some examples.\n\n#GOOD\n## \n#I am trying to create a fake data set to practice some functions on \n#Not to be used for analyses, simply for me\n\nbugs &lt;- data.frame( #naming this 'bugs' and using the data.frame function to build this\n  spiders = rnorm(200), #naming this column 'spiders' and using the rnorm function. This function builds a column with a default mean of 0 and a standard deviation of 1. This column will have 200 values.\n  beetles = rnorm(250), #Same as above, but with 250 values\n  wasps = rnorm(1000) #Same as above, but with 1000 values\n)\n##\n\nIn this example, I clearly noted what I was doing and why I was doing it. For my sake, I can return to this easily. If someone else was to come upon this, they too would be able to understand what my process was.\n\n#BAD\nnotbugs &lt;- data.frame(\n  clover = rnorm(200),\n  shrubberies = rnorm(200),\n  elderberry = rnorm(2000)\n)\n\nIn this example, it is unclear what the purpose of this data set is. Along with that, if someone is not familiar with this script, they may find it very challenging to follow."
  },
  {
    "objectID": "lesson07.html#dplyr-examples",
    "href": "lesson07.html#dplyr-examples",
    "title": "7  Cleaning our data in R",
    "section": "7.1 dplyr Examples",
    "text": "7.1 dplyr Examples\nLet’s start by installing the needed packages. Remember to remove the # symbol to install these packages. We will also call in our Palmer Penguins data set that you downloaded earlier.\n\n#install.packages(\"dplyr\")\nlibrary(dplyr)\n\n#install.packages(\"tidyverse\")\nlibrary(tidyverse)\n\nlibrary(palmerpenguins)\ndata(package = 'palmerpenguins')\n\n\n7.1.1 NAs in R\nBefore we begin, we must first check for missing values. R does not love when NAs get thrown into the mix, especially when running numerical commands, like the mean function.\nTo resolve any missing values, we must first determine if there are any NAs, and where they may be.\nFirst, we will look to see IF and WHERE potential NAs are in our data set. We will do this by using the which function, followed by the is.na function within out penguins data set. What these two functions do together is which locates all of the columns where NAs are present, based on the is.na function. If we wanted to find all of the columns where there were no NAs, we could simply change is.na to !is.na.\n\nwhich(is.na(penguins), arr.ind = TRUE)\n\n      row col\n [1,]   4   3\n [2,] 272   3\n [3,]   4   4\n [4,] 272   4\n [5,]   4   5\n [6,] 272   5\n [7,]   4   6\n [8,] 272   6\n [9,]   4   7\n[10,]   9   7\n[11,]  10   7\n[12,]  11   7\n[13,]  12   7\n[14,]  48   7\n[15,] 179   7\n[16,] 219   7\n[17,] 257   7\n[18,] 269   7\n[19,] 272   7\n\n\nNow that we see there are NAs riddled throughout, we will name a new object (using the same name), but omitting all NAs.\nIn this example, I am using the na.omit function to remove all NAs from our penguin data set. I am also naming this new object (penguins again for ease).\n\npenguins &lt;-\n  na.omit(penguins) #I must add this because there are NAs within this data set and these functions will not work otherwise \n\n\n\nselect()\nLet’s start by selecting for only the columns we are interested in. This can be useful when removing variables we are not currently interested in. Remember, at any manipulation, you can save the changes as a new object which will maintain the integrity of the original if you must back track for whatever reason.\nIn this example, we use the select function to choose which columns we want to look at.\n\n# select()\npenguins %&gt;% #From the penguins data set\n  select(species, bill_length_mm, year) # selecting columns species, bill_length, and      year \n\n# A tibble: 333 × 3\n   species bill_length_mm  year\n   &lt;fct&gt;            &lt;dbl&gt; &lt;int&gt;\n 1 Adelie            39.1  2007\n 2 Adelie            39.5  2007\n 3 Adelie            40.3  2007\n 4 Adelie            36.7  2007\n 5 Adelie            39.3  2007\n 6 Adelie            38.9  2007\n 7 Adelie            39.2  2007\n 8 Adelie            41.1  2007\n 9 Adelie            38.6  2007\n10 Adelie            34.6  2007\n# … with 323 more rows\n\n\nNow that we have selected for certain columns, let’s say we want to view everything except for one or several columns. Instead of typing out every column we want, we can simple type out the one(s) we don’t.\nIn this example, I tell R to remove the sex column using the select function again.\n\n# select()\npenguins %&gt;% #From the penguins data set\n  select(-sex)# selecting all columns except for sex\n\n# A tibble: 333 × 7\n   species island    bill_length_mm bill_depth_mm flipper_length…¹ body_…²  year\n   &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;            &lt;int&gt;   &lt;int&gt; &lt;int&gt;\n 1 Adelie  Torgersen           39.1          18.7              181    3750  2007\n 2 Adelie  Torgersen           39.5          17.4              186    3800  2007\n 3 Adelie  Torgersen           40.3          18                195    3250  2007\n 4 Adelie  Torgersen           36.7          19.3              193    3450  2007\n 5 Adelie  Torgersen           39.3          20.6              190    3650  2007\n 6 Adelie  Torgersen           38.9          17.8              181    3625  2007\n 7 Adelie  Torgersen           39.2          19.6              195    4675  2007\n 8 Adelie  Torgersen           41.1          17.6              182    3200  2007\n 9 Adelie  Torgersen           38.6          21.2              191    3800  2007\n10 Adelie  Torgersen           34.6          21.1              198    4400  2007\n# … with 323 more rows, and abbreviated variable names ¹​flipper_length_mm,\n#   ²​body_mass_g\n\n\nWithin the select function, you can also look for items based on their spelling. This can be especially helpful if you suspect there to be a spelling error somewhere if your data set. In this example, we will search our data set for any variable name that starts with the letter ‘b’.\n\n# select()\npenguins %&gt;% #From the penguins data set\n  select(starts_with('b')) # selecting columns that start with 'b' and using starts_with\n\n# A tibble: 333 × 3\n   bill_length_mm bill_depth_mm body_mass_g\n            &lt;dbl&gt;         &lt;dbl&gt;       &lt;int&gt;\n 1           39.1          18.7        3750\n 2           39.5          17.4        3800\n 3           40.3          18          3250\n 4           36.7          19.3        3450\n 5           39.3          20.6        3650\n 6           38.9          17.8        3625\n 7           39.2          19.6        4675\n 8           41.1          17.6        3200\n 9           38.6          21.2        3800\n10           34.6          21.1        4400\n# … with 323 more rows\n\n\n\n\nrename()\nNow that we have viewed and selected for different columns and such, we manipulate our data set further. We will start by renaming some columns. Notice with rename, there are two methods you can use. One without quotation marks, and one with.\nIn this example, using the rename function, I am changing ‘species’ to ‘Species and ’year’ to ‘Year’.\n\n# rename()\npenguins %&gt;%\n  select(species, bill_length_mm, year) %&gt;% #selecting the columns I want to look at\n  rename( #rename function. notice here the two methods of changing names\n    Species = species, #changing species to Species without quotes\n    \"Year\" = year #changing year to Year with quotes\n  )\n\n# A tibble: 333 × 3\n   Species bill_length_mm  Year\n   &lt;fct&gt;            &lt;dbl&gt; &lt;int&gt;\n 1 Adelie            39.1  2007\n 2 Adelie            39.5  2007\n 3 Adelie            40.3  2007\n 4 Adelie            36.7  2007\n 5 Adelie            39.3  2007\n 6 Adelie            38.9  2007\n 7 Adelie            39.2  2007\n 8 Adelie            41.1  2007\n 9 Adelie            38.6  2007\n10 Adelie            34.6  2007\n# … with 323 more rows\n\n\n\n\narrange()\nlet’s arrange some stuff this is equivalent to sort!\nOne of the first steps we take in Excel is the sorting of our data sets. Whether that be the sorting of plots, or dates, or anything; we start by sorting. The same is possible in R. We do this using the arrange function.\nIn this example, we will be sorting by bill length in an increasing order (smallest to largest). Notice here that R will default to the order of small-large with the arrange function.\n\n# select() and arrange()\npenguins %&gt;%\n  select(species, bill_length_mm, year) %&gt;% \n  arrange(bill_length_mm) #I want to look at bill length in an increasing order from      smallest to largest \n\n# A tibble: 333 × 3\n   species bill_length_mm  year\n   &lt;fct&gt;            &lt;dbl&gt; &lt;int&gt;\n 1 Adelie            32.1  2009\n 2 Adelie            33.1  2008\n 3 Adelie            33.5  2008\n 4 Adelie            34    2008\n 5 Adelie            34.4  2007\n 6 Adelie            34.5  2008\n 7 Adelie            34.6  2007\n 8 Adelie            34.6  2008\n 9 Adelie            35    2008\n10 Adelie            35    2009\n# … with 323 more rows\n\n\nIn this example, we will be sorting by bill length in a decreasing order (largest to smallest). Notice here, we need the arrange function to tell R we will be changing the order. Once that command is established, we can further command the order.\nIn this example, I use the arrange function, followed by the desc function (descending), commanding the order of bill length to go from big to small values.\n\n# select(), arrange(), and desc()\npenguins %&gt;%\n  select(species, bill_length_mm, year) %&gt;% \n  arrange(desc(bill_length_mm)) #using the desc() function to command the order from      largest to smallest \n\n# A tibble: 333 × 3\n   species   bill_length_mm  year\n   &lt;fct&gt;              &lt;dbl&gt; &lt;int&gt;\n 1 Gentoo              59.6  2007\n 2 Chinstrap           58    2007\n 3 Gentoo              55.9  2009\n 4 Chinstrap           55.8  2009\n 5 Gentoo              55.1  2009\n 6 Gentoo              54.3  2008\n 7 Chinstrap           54.2  2008\n 8 Chinstrap           53.5  2008\n 9 Gentoo              53.4  2009\n10 Chinstrap           52.8  2008\n# … with 323 more rows\n\n\nNow, let’s say we want to see bill length in the same descending order, but we want order this by year. This is done with a very simple addition to our arrange() section. To accomplish this, we add the year variable first (remembering the the default for arrange is small-large) followed by the bill length command (which is the same as the previous example.)\n\n# select() and arrange()\npenguins %&gt;%\n  select(species, bill_length_mm, year) %&gt;% \n  arrange(year, desc(bill_length_mm)) #year and bill separated by a comma\n\n# A tibble: 333 × 3\n   species   bill_length_mm  year\n   &lt;fct&gt;              &lt;dbl&gt; &lt;int&gt;\n 1 Gentoo              59.6  2007\n 2 Chinstrap           58    2007\n 3 Chinstrap           52.7  2007\n 4 Chinstrap           52    2007\n 5 Chinstrap           52    2007\n 6 Chinstrap           51.7  2007\n 7 Chinstrap           51.3  2007\n 8 Chinstrap           51.3  2007\n 9 Chinstrap           51.3  2007\n10 Chinstrap           50.6  2007\n# … with 323 more rows\n\n\n\n\nfilter()\nWithin R, we also have the ability to subset out data sets and pull out rows with specific values. Let’s say I only want to look at data from 2007. To accomplish this, we will use the filter function.\nIn this example, we will be adding the filter function as well as recall our knowledge of (operators) within R.\n\n# select() and filter()\npenguins %&gt;%\n  select(species, bill_length_mm, bill_depth_mm, year) %&gt;% \n  filter(year == 2007) #using the '==' operator to show everything with the year 2007\n\n# A tibble: 103 × 4\n   species bill_length_mm bill_depth_mm  year\n   &lt;fct&gt;            &lt;dbl&gt;         &lt;dbl&gt; &lt;int&gt;\n 1 Adelie            39.1          18.7  2007\n 2 Adelie            39.5          17.4  2007\n 3 Adelie            40.3          18    2007\n 4 Adelie            36.7          19.3  2007\n 5 Adelie            39.3          20.6  2007\n 6 Adelie            38.9          17.8  2007\n 7 Adelie            39.2          19.6  2007\n 8 Adelie            41.1          17.6  2007\n 9 Adelie            38.6          21.2  2007\n10 Adelie            34.6          21.1  2007\n# … with 93 more rows\n\n\nWhat if I want to see within the year 2007, which penguins have bill lengths higher than the mean of them all? This can be accomplished by, again, adding an operator, but also calling another function. We will command R further with mean function from base R. Notice I am separating each line in the filter function with a comma. This allows me to add multiple commands within the same function.\n\n# select(), filter(), and mean()\n\npenguins %&gt;%\n  select(species, bill_length_mm, year) %&gt;% \n  filter(\n    year == 2007,#using the '==' operator to show everything with the year 2007\n    bill_length_mm &lt; mean(bill_length_mm), # using the '&lt;' to to view every row where the bill length is less than the avg bill length \n  ) \n\n# A tibble: 49 × 3\n   species bill_length_mm  year\n   &lt;fct&gt;            &lt;dbl&gt; &lt;int&gt;\n 1 Adelie            39.1  2007\n 2 Adelie            39.5  2007\n 3 Adelie            40.3  2007\n 4 Adelie            36.7  2007\n 5 Adelie            39.3  2007\n 6 Adelie            38.9  2007\n 7 Adelie            39.2  2007\n 8 Adelie            41.1  2007\n 9 Adelie            38.6  2007\n10 Adelie            34.6  2007\n# … with 39 more rows\n\n\nLet’s say we are interested in manipulating our data set by species.\nI want to know how many species I have to further filter this set. To accomplish this, I will use the the count function to view how many species I have and their associated values within the data set.\n\n# count()\npenguins %&gt;% \n  count(species)\n\n# A tibble: 3 × 2\n  species       n\n  &lt;fct&gt;     &lt;int&gt;\n1 Adelie      146\n2 Chinstrap    68\n3 Gentoo      119\n\n\nIt appears there are three species within my data set. For one reason or another, I want to filter out Adelie from further interpretations. To do this, I will add another line below the bill length filter.\nThis new line says when species equals Chinstrap OR Gentoo, keep them in the data set.\n\n# filter()\npenguins %&gt;%\n  select(species, bill_length_mm, year) %&gt;% \n  filter(\n    year == 2007,#using the '==' operator to show everything with the year 2007\n    bill_length_mm &lt; mean(bill_length_mm),# using the '&lt;' to to view every row where the bill length is less than the avg bill length \n    species == \"Chinstrap\" | species == \"Gentoo\" # look in species and pull out chinstrap and gentoo. | allows to command two species, similar to 'or'\n  ) \n\n# A tibble: 7 × 3\n  species   bill_length_mm  year\n  &lt;fct&gt;              &lt;dbl&gt; &lt;int&gt;\n1 Gentoo              43.3  2007\n2 Gentoo              40.9  2007\n3 Gentoo              42    2007\n4 Gentoo              42.9  2007\n5 Gentoo              42.8  2007\n6 Chinstrap           42.4  2007\n7 Chinstrap           43.2  2007\n\n\nAnother way to accomplish the same task is to tell R which values to exclude, rather than include. This is done by using the ‘does not equal’ operator to command R to return every species value that is not Adelie.\n\n# filter()\npenguins %&gt;%\n  select(species, bill_length_mm, year) %&gt;% \n  filter(\n    year == 2007,#using the '==' operator to show everything with the year 2007\n    bill_length_mm &lt; mean(bill_length_mm),# using the '&lt;' to to view every row where the bill length is less than the avg bill length \n    species != \"Adelie\" #does not equal operator\n  ) \n\n# A tibble: 7 × 3\n  species   bill_length_mm  year\n  &lt;fct&gt;              &lt;dbl&gt; &lt;int&gt;\n1 Gentoo              43.3  2007\n2 Gentoo              40.9  2007\n3 Gentoo              42    2007\n4 Gentoo              42.9  2007\n5 Gentoo              42.8  2007\n6 Chinstrap           42.4  2007\n7 Chinstrap           43.2  2007\n\n#the output is the same!\n\nNow that we only the data we want to see, let’s create some new columns and row values. Let’s say we want to add a new column combining species and year and a new column with the rounded values of bill length. We will be using the mutate function here. Along with this, we then want to rearrange our data set for viewing purposes of our new variables. This will be done with the select function.\nIn this example, I have created the column ‘sp_year’ which will contain both species and year, but keep their respective values separated by a dash. I then created a new column of the rounded bill length values using the round function. Notice with these new columns, the first step is to name the new column and then command R what to put in. Lastly, using the select function, I command R to order this data set as follows.\n\npenguins %&gt;%\n  select(species, bill_length_mm, year) %&gt;% \n  mutate( #mutate()\n    sp_year = paste(species, \"-\", year), #adding a new column named 'sp_year' and pasting the species column and year column with a dash between them. \n    rn_bill_length_mm = round(bill_length_mm) #creating a column of rounded bill lengths \n  ) %&gt;% \n  select(species, year, sp_year, bill_length_mm, rn_bill_length_mm) #placing these new columns an order I would like \n\n# A tibble: 333 × 5\n   species  year sp_year       bill_length_mm rn_bill_length_mm\n   &lt;fct&gt;   &lt;int&gt; &lt;chr&gt;                  &lt;dbl&gt;             &lt;dbl&gt;\n 1 Adelie   2007 Adelie - 2007           39.1                39\n 2 Adelie   2007 Adelie - 2007           39.5                40\n 3 Adelie   2007 Adelie - 2007           40.3                40\n 4 Adelie   2007 Adelie - 2007           36.7                37\n 5 Adelie   2007 Adelie - 2007           39.3                39\n 6 Adelie   2007 Adelie - 2007           38.9                39\n 7 Adelie   2007 Adelie - 2007           39.2                39\n 8 Adelie   2007 Adelie - 2007           41.1                41\n 9 Adelie   2007 Adelie - 2007           38.6                39\n10 Adelie   2007 Adelie - 2007           34.6                35\n# … with 323 more rows\n\n\n\n\nsummarize()\nNow that we are confident in our wrangling, we can investigate some summary statistics.\nFirst, let’s look at the means and standard deviations of both bill length and depth. This will be done by name new columns and then using either the mean function or sd function to produce a desired output.\n\npenguins %&gt;% \n  summarize( #summarize to run summary stats \n  bill_length_mean = mean(bill_length_mm), #new column with mean value of bill length\n  bill_length_sd = sd(bill_length_mm), #new column with standard deviation value of bill length\n  bill_depth_mean = mean(bill_depth_mm), #new column with mean value of bill depth\n  bill_depth_sd = sd(bill_depth_mm) #new column with standard deviation value of bill depth\n  )\n\n# A tibble: 1 × 4\n  bill_length_mean bill_length_sd bill_depth_mean bill_depth_sd\n             &lt;dbl&gt;          &lt;dbl&gt;           &lt;dbl&gt;         &lt;dbl&gt;\n1             44.0           5.47            17.2          1.97\n\n\nThe last output was informative, but lets look a little deeper. I now want to group these new values by species. Using the group_by function, we can tell R to group our data set by one, or more variables.\nIn this example, I am telling R to group_by species, and then provide me with the means and standard deviations of bill length and depth.\n\npenguins %&gt;% \n  group_by(species) %&gt;% #grouping by one column, species \n  summarize( #summarize to run summary stats \n    bill_length_mean = mean(bill_length_mm), #new column with mean value of bill length\n    bill_length_sd = sd(bill_length_mm), #new column with standard deviation value of bill length\n    bill_depth_mean = mean(bill_depth_mm), #new column with mean value of bill depth\n    bill_depth_sd = sd(bill_depth_mm) #new column with standard deviation value of bill depth\n  )\n\n# A tibble: 3 × 5\n  species   bill_length_mean bill_length_sd bill_depth_mean bill_depth_sd\n  &lt;fct&gt;                &lt;dbl&gt;          &lt;dbl&gt;           &lt;dbl&gt;         &lt;dbl&gt;\n1 Adelie                38.8           2.66            18.3         1.22 \n2 Chinstrap             48.8           3.34            18.4         1.14 \n3 Gentoo                47.6           3.11            15.0         0.986\n\n\nFollowing the trend of the last example, let’s further group our data set. I want to now see these same values but by species AND year. Using the group_by function again, we can accomplish this.\nIn this example, the only change is I added ‘, year’ into my group_by function.\n\npenguins %&gt;% \n  group_by(species, year) %&gt;% #grouping by two columns, species and year \n  summarize( #summarize to run summary stats \n    bill_length_mean = mean(bill_length_mm), #new column with mean value of bill length\n    bill_length_sd = sd(bill_length_mm), #new column with standard deviation value of bill length\n    bill_depth_mean = mean(bill_depth_mm), #new column with mean value of bill depth\n    bill_depth_sd = sd(bill_depth_mm) #new column with standard deviation value of bill depth\n  )\n\n`summarise()` has grouped output by 'species'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 9 × 6\n# Groups:   species [3]\n  species    year bill_length_mean bill_length_sd bill_depth_mean bill_depth_sd\n  &lt;fct&gt;     &lt;int&gt;            &lt;dbl&gt;          &lt;dbl&gt;           &lt;dbl&gt;         &lt;dbl&gt;\n1 Adelie     2007             38.9           2.44            18.8         1.23 \n2 Adelie     2008             38.6           2.98            18.2         1.09 \n3 Adelie     2009             39.0           2.56            18.1         1.24 \n4 Chinstrap  2007             48.7           3.47            18.5         1.00 \n5 Chinstrap  2008             48.7           3.62            18.4         1.40 \n6 Chinstrap  2009             49.1           3.10            18.3         1.10 \n7 Gentoo     2007             47.1           3.29            14.7         0.919\n8 Gentoo     2008             47.0           2.66            14.9         0.993\n9 Gentoo     2009             48.6           3.19            15.3         0.967"
  },
  {
    "objectID": "lesson07.html#practice-on-your-own",
    "href": "lesson07.html#practice-on-your-own",
    "title": "7  Cleaning our data in R",
    "section": "7.2 Practice on your own",
    "text": "7.2 Practice on your own\nNow that we have worked through some examples with Palmer Penguins, let’s try and work through a data set of our own.\nAttached here is a (Slug data set.)\nRemember, you will need to import this file into R in the correct format!\nYour task is to [1] input it into R, [2] investigate the variables and classes of these variables, [3] produce an output using each of the functions we just covered, [4] and at least one example where you use select, rename, arrange, filter, mutate, and group_by in the same command line. In part 3, for each change to the data set, save the changed data set as a new object. For part 4, save this object as, ‘Final_Changes’. If you conduct more than one iteration of part 4, add the associated number at the end of each name. For example, Final_Changes_1, Final_Changes_2, etc."
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "8  Resources and cheat sheets",
    "section": "",
    "text": "Cheat sheet links\n(Data Table)\n(dplyr and tidyr)\n(ggplot)"
  },
  {
    "objectID": "Glossary.html",
    "href": "Glossary.html",
    "title": "9  Terms of endearment",
    "section": "",
    "text": "Shout out to Daniel Bliss for listening to me think about loud during this process and also for being the first person to proof read.\nChief editor: Daniel D’Bliss"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "What is R?\n\nnd. “What is R?” The R Foundation. (link)\n\nRStudio vs r\n\nnd. “R and RStudio” BYU: Department of Statistics. (link)\n\nExcel vs r\n\nAbrahams, Amieroh. February 23,2023. “Why should I use R: The Excel R Data Wrangling comparison” jumping rivers. (link)\n\nStyle\n\nnd. “The tidyverse style guide” tidyverse. (link)\nnd. “Google’s R Style Guide” styleguide. (link)"
  }
]