{
  "hash": "fedbc698cf9e96dca66e0ee2e02895ab",
  "result": {
    "markdown": "# Data wrangling \n## Cleaning our data in R \n###  R > excel {.unnumbered}\n\nBefore we begin wrangling our data set, let's quickly discuss why cleaning data in R is important. \nFirst and foremost, my Excel file never needs to change. \nAlong with this, I only need to save it once. \nNo saving a new copy every time I make a new column or want to write a formula. \n\nIn this section, we will go over some important packages and key functions that will aid in the transition from Excel-based data wrangling to exclusively R-based data wrangling. \nSO, without further ado, lettuce begin. \n\n### What we use to wrangle {.unnumbered}\nWhen we wrangle our data sets, there is one 'umbrella' package I find to be the most versatile. \nThis is **tidyverse**.\n**Tidyverse** houses many useful packages for data manipulation, but in this section I will only be referring to one. \nThis package is **dplyr**. \nWhile I rely on this package a lot, I also use functions pre-installed in Base R while wrangling. \n\nPlease see the wrangling cheat sheets [here](resources.qmd).\n\n## dplyr Examples\n\n\nLet's start by installing the needed packages. Remember to remove the # symbol to install these packages. We will also call in our Palmer Penguins data set that you downloaded earlier.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#install.packages(\"dplyr\")\nlibrary(dplyr)\n\n#install.packages(\"tidyverse\")\nlibrary(tidyverse)\n\nlibrary(palmerpenguins)\ndata(package = 'palmerpenguins') #investigating the pieces of this data set. How many data sets are there? \n```\n:::\n\n\n### NAs in R {.unnumbered}\nBefore we begin, we must first check for missing values.\nR *does not* love when NAs get thrown into the mix, especially when running numerical commands, like the **mean** function.  \nTo resolve any missing values, we must first determine if there are any NAs, and where they may be. \n\nFirst, we will look to see IF and WHERE potential NAs are in our data set.\nWe will do this by using the **which** function, followed by the **is.na** function within our penguins data set. \nWhat these two functions do together is which locates all of the columns where NAs are present, based on the **is.na** function. \nIf we wanted to find all of the columns where there were no NAs, we could simply change **is.na** to **!is.na**.\n\nIn this example, my command is to determine where the NAs are. Using the *arr.ind = TRUE* command, I am telling R to show me *exactly* where they are. \nIn this example we are using *penguins_raw*. \nThis is the **only** section that will use the raw data set in the example. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nwhich(is.na(penguins_raw), arr.ind = TRUE) #checking for NA locations in penguins_raw\n```\n:::\n\n\nNow that we see there are NAs riddled throughout, we will name a new object (using the same name), but omitting all NAs. \n\nIn this example, I am using the **na.omit** function to remove all NAs from our penguin data set. \nI am also naming this new object (penguins_raw again for ease).\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins_raw <-\n  na.omit(penguins_raw) #I must add this because there are NAs within this data set and these functions will not work otherwise \n```\n:::\n\n\n### select() {.unnumbered}\n\nLet's start by selecting for only the columns we are interested in. \nThis can be useful when removing variables we are not currently interested in. \n**Remember**, at any manipulation, you can save the changes as a new object which will maintain the integrity of the original if you must back track for whatever reason. \n\nIn this example, we use the **select** function to choose which columns we want to look at. \n*Notice*, we are back to using *penguins*!\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# select()\npenguins %>% #From the penguins data set\n  select(species, bill_length_mm, year) # selecting columns species, bill_length, and      year \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 344 × 3\n   species bill_length_mm  year\n   <fct>            <dbl> <int>\n 1 Adelie            39.1  2007\n 2 Adelie            39.5  2007\n 3 Adelie            40.3  2007\n 4 Adelie            NA    2007\n 5 Adelie            36.7  2007\n 6 Adelie            39.3  2007\n 7 Adelie            38.9  2007\n 8 Adelie            39.2  2007\n 9 Adelie            34.1  2007\n10 Adelie            42    2007\n# … with 334 more rows\n```\n:::\n:::\n\n\nNow that we have selected for certain columns, let's say we want to view everything except for one or several columns.\nInstead of typing out every column we want, we can simple type out the one(s) we don't.\n\nIn this example, I tell R to remove the sex column using the **select** function again.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# select()\npenguins %>% #From the penguins data set\n  select(-sex)# selecting all columns except for sex\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 344 × 7\n   species island    bill_length_mm bill_depth_mm flipper_length…¹ body_…²  year\n   <fct>   <fct>              <dbl>         <dbl>            <int>   <int> <int>\n 1 Adelie  Torgersen           39.1          18.7              181    3750  2007\n 2 Adelie  Torgersen           39.5          17.4              186    3800  2007\n 3 Adelie  Torgersen           40.3          18                195    3250  2007\n 4 Adelie  Torgersen           NA            NA                 NA      NA  2007\n 5 Adelie  Torgersen           36.7          19.3              193    3450  2007\n 6 Adelie  Torgersen           39.3          20.6              190    3650  2007\n 7 Adelie  Torgersen           38.9          17.8              181    3625  2007\n 8 Adelie  Torgersen           39.2          19.6              195    4675  2007\n 9 Adelie  Torgersen           34.1          18.1              193    3475  2007\n10 Adelie  Torgersen           42            20.2              190    4250  2007\n# … with 334 more rows, and abbreviated variable names ¹​flipper_length_mm,\n#   ²​body_mass_g\n```\n:::\n:::\n\n\nWithin the **select** function, you can also look for items based on their spelling. This can be especially helpful if you suspect there to be a spelling error somewhere if your data set. In this example, we will search our data set for any variable name that starts with the letter 'b'.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# select()\npenguins %>% #From the penguins data set\n  select(starts_with('b')) # selecting columns that start with 'b' and using starts_with\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 344 × 3\n   bill_length_mm bill_depth_mm body_mass_g\n            <dbl>         <dbl>       <int>\n 1           39.1          18.7        3750\n 2           39.5          17.4        3800\n 3           40.3          18          3250\n 4           NA            NA            NA\n 5           36.7          19.3        3450\n 6           39.3          20.6        3650\n 7           38.9          17.8        3625\n 8           39.2          19.6        4675\n 9           34.1          18.1        3475\n10           42            20.2        4250\n# … with 334 more rows\n```\n:::\n:::\n\n\n\n### rename() {.unnumbered}\n\nNow that we have viewed and selected for different columns and such, we manipulate our data set further.\nWe will start by renaming some columns. \nNotice with rename, there are two methods you can use. \nOne *without* quotation marks, and one *with.*\n\nIn this example, using the **rename** function, I am changing 'species' to 'Species and 'year' to 'Year'.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# rename()\npenguins %>%\n  select(species, bill_length_mm, year) %>% #selecting the columns I want to look at\n  rename( #rename function. notice here the two methods of changing names\n    Species = species, #changing species to Species without quotes\n    \"Year\" = year #changing year to Year with quotes\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 344 × 3\n   Species bill_length_mm  Year\n   <fct>            <dbl> <int>\n 1 Adelie            39.1  2007\n 2 Adelie            39.5  2007\n 3 Adelie            40.3  2007\n 4 Adelie            NA    2007\n 5 Adelie            36.7  2007\n 6 Adelie            39.3  2007\n 7 Adelie            38.9  2007\n 8 Adelie            39.2  2007\n 9 Adelie            34.1  2007\n10 Adelie            42    2007\n# … with 334 more rows\n```\n:::\n:::\n\n\n### arrange() {.unnumbered}\n\nlet's arrange some stuff\nthis is equivalent to sort!\n\nOne of the first steps we take in *Excel* is the **sorting** of our data sets.\nWhether that be the sorting of plots, or dates, or anything; we start by sorting. \nThe same is possible in R. \nWe do this using the **arrange** function.\n\nIn this example, we will be sorting by bill length in an increasing order (smallest to largest). Notice here that R will *default* to the order of small-large with the **arrange** function.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# select() and arrange()\npenguins %>%\n  select(species, bill_length_mm, year) %>% \n  arrange(bill_length_mm) #I want to look at bill length in an increasing order from      smallest to largest \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 344 × 3\n   species bill_length_mm  year\n   <fct>            <dbl> <int>\n 1 Adelie            32.1  2009\n 2 Adelie            33.1  2008\n 3 Adelie            33.5  2008\n 4 Adelie            34    2008\n 5 Adelie            34.1  2007\n 6 Adelie            34.4  2007\n 7 Adelie            34.5  2008\n 8 Adelie            34.6  2007\n 9 Adelie            34.6  2008\n10 Adelie            35    2008\n# … with 334 more rows\n```\n:::\n:::\n\n\nIn this example, we will be sorting by bill length in a decreasing order (largest to smallest).\nNotice here, we need the **arrange** function to tell R we will be changing the order. \nOnce that command is established, we can further command the order. \n\nIn this example, I use the **arrange** function, followed by the **desc** function (descending), commanding the order of bill length to go from big to small values. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# select(), arrange(), and desc()\npenguins %>%\n  select(species, bill_length_mm, year) %>% \n  arrange(desc(bill_length_mm)) #using the desc() function to command the order from      largest to smallest \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 344 × 3\n   species   bill_length_mm  year\n   <fct>              <dbl> <int>\n 1 Gentoo              59.6  2007\n 2 Chinstrap           58    2007\n 3 Gentoo              55.9  2009\n 4 Chinstrap           55.8  2009\n 5 Gentoo              55.1  2009\n 6 Gentoo              54.3  2008\n 7 Chinstrap           54.2  2008\n 8 Chinstrap           53.5  2008\n 9 Gentoo              53.4  2009\n10 Chinstrap           52.8  2008\n# … with 334 more rows\n```\n:::\n:::\n\n\nNow, let's say we want to see bill length in the same descending order, but we want to order this by year. \nThis is done with a very simple addition to our *arrange()* section. \nTo accomplish this, we add the year variable first (remembering the the default for **arrange** is small-large) followed by the bill length command (which is the same as the previous example.)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# select() and arrange()\npenguins %>%\n  select(species, bill_length_mm, year) %>% \n  arrange(year, desc(bill_length_mm)) #year and bill separated by a comma\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 344 × 3\n   species   bill_length_mm  year\n   <fct>              <dbl> <int>\n 1 Gentoo              59.6  2007\n 2 Chinstrap           58    2007\n 3 Chinstrap           52.7  2007\n 4 Chinstrap           52    2007\n 5 Chinstrap           52    2007\n 6 Chinstrap           51.7  2007\n 7 Chinstrap           51.3  2007\n 8 Chinstrap           51.3  2007\n 9 Chinstrap           51.3  2007\n10 Chinstrap           50.6  2007\n# … with 334 more rows\n```\n:::\n:::\n\n\n### filter() {.unnumbered}\nWithin R, we also have the ability to subset out data sets and pull out rows with specific values. \nLet's say I *only* want to look at data from *2007.* \nTo accomplish this, we will use the **filter** function. \n\nIn this example, we will be adding the **filter** function as well as recall our knowledge of ([operators](lesson04.qmd)) within R.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# select() and filter()\npenguins %>%\n  select(species, bill_length_mm, bill_depth_mm, year) %>% \n  filter(year == 2007) #using the '==' operator to show everything with the year 2007\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 110 × 4\n   species bill_length_mm bill_depth_mm  year\n   <fct>            <dbl>         <dbl> <int>\n 1 Adelie            39.1          18.7  2007\n 2 Adelie            39.5          17.4  2007\n 3 Adelie            40.3          18    2007\n 4 Adelie            NA            NA    2007\n 5 Adelie            36.7          19.3  2007\n 6 Adelie            39.3          20.6  2007\n 7 Adelie            38.9          17.8  2007\n 8 Adelie            39.2          19.6  2007\n 9 Adelie            34.1          18.1  2007\n10 Adelie            42            20.2  2007\n# … with 100 more rows\n```\n:::\n:::\n\n\nWhat if I want to see which penguins have bill lengths that are higher than the average length, but *only* from 2007?\nThis can be accomplished by, again, adding an operator, but also calling another function. \nWe will command R further with **mean** function from base R. \nNotice I am separating each line in the **filter** function with a comma. \nThis allows me to add multiple commands within the same function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# select(), filter(), and mean()\n\npenguins %>%\n  select(species, bill_length_mm, year) %>% \n  filter(\n    year == 2007,#using the '==' operator to show everything with the year 2007\n    bill_length_mm > mean(bill_length_mm), # using '>' to view every row where the bill length is greater than the avg bill length \n  ) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 0 × 3\n# … with 3 variables: species <fct>, bill_length_mm <dbl>, year <int>\n```\n:::\n:::\n\n\n\nLet's say we are interested in manipulating our data set by species.  \nI want to know how many species I have to further filter this set. \nTo accomplish this, I will use the the **count** function to view how many species I have and their associated values within the data set.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# count()\npenguins %>% \n  count(species)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n  species       n\n  <fct>     <int>\n1 Adelie      152\n2 Chinstrap    68\n3 Gentoo      124\n```\n:::\n:::\n\n\nIt appears there are three species within my data set.\nFor one reason or another, I want to filter out *Adelie* from further interpretations. \nTo do this, I will add another line below the bill length filter. \n\nThis new line says *when species equals Chinstrap OR Gentoo*, keep them in the data set.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# select() and filter()\npenguins %>%\n  select(species, bill_length_mm, year) %>% \n  filter(\n    year == 2007,#using the '==' operator to show everything with the year 2007\n    bill_length_mm > mean(bill_length_mm),# using '>' to view every row where the bill length is greater than the avg bill length\n    species == \"Chinstrap\" | species == \"Gentoo\" # look in species and pull out chinstrap and gentoo. | allows to command two species, similar to 'or'\n  ) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 0 × 3\n# … with 3 variables: species <fct>, bill_length_mm <dbl>, year <int>\n```\n:::\n:::\n\n\n\nAnother way to accomplish the same task is to tell R which values to *exclude*, rather than *include.* \nThis is done by using the 'does not equal' operator to command R to return every species value that is not Adelie.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# select () and filter()\npenguins %>%\n  select(species, bill_length_mm, year) %>% \n  filter(\n    year == 2007,#using the '==' operator to show everything with the year 2007\n    bill_length_mm > mean(bill_length_mm),# using '>' to view every row where the bill length is greater than the avg bill length \n    species != \"Adelie\" #does not equal operator\n  ) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 0 × 3\n# … with 3 variables: species <fct>, bill_length_mm <dbl>, year <int>\n```\n:::\n\n```{.r .cell-code}\n#the output is the same!\n```\n:::\n\n\nNow that we only the data we want to see, let's create some new columns and row values. \nLet's say we want to add a new column combining *species and year* and a new column with the *rounded values of bill length*. \nWe will be using the **mutate** function here.\nAlong with this, we then want to *rearrange* our data set for viewing purposes of our new variables. \nThis will be done with the **select** function. \n\nIn this example, I have created the column 'sp_year' which will contain both species and year, but keep their respective values separated by a dash. \nI then created a new column of the rounded bill length values using the **round** function. \n*Notice* with these new columns, the first step is to name the new column and then command R what to put in. \nLastly, using the **select** function, I command R to order this data set as follows.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# select(), mutate(), select()\npenguins %>%\n  select(species, bill_length_mm, year) %>% \n  mutate( #mutate()\n    sp_year = paste(species, \"-\", year), #adding a new column named 'sp_year' and pasting the species column and year column with a dash between them. \n    rn_bill_length_mm = round(bill_length_mm) #creating a column of rounded bill lengths \n  ) %>% \n  select(species, year, sp_year, bill_length_mm, rn_bill_length_mm) #placing these new columns an order I would like \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 344 × 5\n   species  year sp_year       bill_length_mm rn_bill_length_mm\n   <fct>   <int> <chr>                  <dbl>             <dbl>\n 1 Adelie   2007 Adelie - 2007           39.1                39\n 2 Adelie   2007 Adelie - 2007           39.5                40\n 3 Adelie   2007 Adelie - 2007           40.3                40\n 4 Adelie   2007 Adelie - 2007           NA                  NA\n 5 Adelie   2007 Adelie - 2007           36.7                37\n 6 Adelie   2007 Adelie - 2007           39.3                39\n 7 Adelie   2007 Adelie - 2007           38.9                39\n 8 Adelie   2007 Adelie - 2007           39.2                39\n 9 Adelie   2007 Adelie - 2007           34.1                34\n10 Adelie   2007 Adelie - 2007           42                  42\n# … with 334 more rows\n```\n:::\n:::\n\n\n### summarize() {.unnumbered}\n\nNow that we are confident in our wrangling, we can investigate some summary statistics. \n\nFirst, let's look at the means and standard deviations of both bill length and depth.\nThis will be done by name new columns and then using either the **mean** function or **sd** function to produce a desired output.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# summarize ()\npenguins %>% \n  summarize( #summarize to run summary stats \n  bill_length_mean = mean(bill_length_mm), #new column with mean value of bill length\n  bill_length_sd = sd(bill_length_mm), #new column with standard deviation value of bill length\n  bill_depth_mean = mean(bill_depth_mm), #new column with mean value of bill depth\n  bill_depth_sd = sd(bill_depth_mm) #new column with standard deviation value of bill depth\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 4\n  bill_length_mean bill_length_sd bill_depth_mean bill_depth_sd\n             <dbl>          <dbl>           <dbl>         <dbl>\n1               NA             NA              NA            NA\n```\n:::\n:::\n\n\n\nThe last output was informative, but lets look a little deeper.\nI now want to group these new values by species. \nUsing the **group_by** function, we can tell R to group our data set by one, or more variables. \n\nIn this example, I am telling R to **group_by** species, and then provide me with the means and standard deviations of bill length and depth. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# group_by() and summarize()\npenguins %>% \n  group_by(species) %>% #grouping by one column, species \n  summarize( #summarize to run summary stats \n    bill_length_mean = mean(bill_length_mm), #new column with mean value of bill length\n    bill_length_sd = sd(bill_length_mm), #new column with standard deviation value of bill length\n    bill_depth_mean = mean(bill_depth_mm), #new column with mean value of bill depth\n    bill_depth_sd = sd(bill_depth_mm) #new column with standard deviation value of bill depth\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 5\n  species   bill_length_mean bill_length_sd bill_depth_mean bill_depth_sd\n  <fct>                <dbl>          <dbl>           <dbl>         <dbl>\n1 Adelie                NA            NA               NA           NA   \n2 Chinstrap             48.8           3.34            18.4          1.14\n3 Gentoo                NA            NA               NA           NA   \n```\n:::\n:::\n\n\nFollowing the trend of the last example, let's further group our data set. \nI want to now see these same values but by species AND year. \nUsing the **group_by** function again, we can accomplish this. \n\nIn this example, the only change is I added ', year' into my **group_by** function. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# group_by() and summarize()\npenguins %>% \n  group_by(species, year) %>% #grouping by two columns, species and year \n  summarize( #summarize to run summary stats \n    bill_length_mean = mean(bill_length_mm), #new column with mean value of bill length\n    bill_length_sd = sd(bill_length_mm), #new column with standard deviation value of bill length\n    bill_depth_mean = mean(bill_depth_mm), #new column with mean value of bill depth\n    bill_depth_sd = sd(bill_depth_mm) #new column with standard deviation value of bill depth\n  )\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'species'. You can override using the\n`.groups` argument.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 9 × 6\n# Groups:   species [3]\n  species    year bill_length_mean bill_length_sd bill_depth_mean bill_depth_sd\n  <fct>     <int>            <dbl>          <dbl>           <dbl>         <dbl>\n1 Adelie     2007             NA            NA               NA          NA    \n2 Adelie     2008             38.6           2.98            18.2         1.09 \n3 Adelie     2009             39.0           2.56            18.1         1.24 \n4 Chinstrap  2007             48.7           3.47            18.5         1.00 \n5 Chinstrap  2008             48.7           3.62            18.4         1.40 \n6 Chinstrap  2009             49.1           3.10            18.3         1.10 \n7 Gentoo     2007             47.0           3.27            14.7         0.908\n8 Gentoo     2008             46.9           2.64            14.9         0.985\n9 Gentoo     2009             NA            NA               NA          NA    \n```\n:::\n:::\n\n\n\n## Practice on your own \n\nFirst, take the penguins_raw data set and get it as close to the cleaned data set, penguins, as you can. \nUse the methods we went over in this section, and apply changes where needed. \n**Hint**, the is.na section is already ~done~. \nOnce complete, continue to the next practice assignment. \n\nNow that we have worked through some examples with Palmer Penguins, let's try and work through a data set of our own. \n\n\nAttached here is a [Slug data set.](https://pennstateoffice365-my.sharepoint.com/:x:/g/personal/jqa5357_psu_edu/EXojojTCn3lMlCm5-UZZejsBFgoLjtoMTZZHwdtZKtd6bw?e=lId60J)\n\n**Remember**, you will need to import this file into R in the correct format!\n\nYour task is to [1] input it into R, [2] investigate the variables and classes of these variables, [3] produce an output using *each* of the functions we just covered, [4] and at least *one* example where you use **select, rename, arrange, filter, mutate, and group_by** in the same command line. In part 3, for each change to the data set, save the changed data set as a new object. For part 4, save this object as, 'Final_Changes'. If you conduct more than one iteration of part 4, add the associated number at the end of each name. For example, Final_Changes_1, Final_Changes_2, etc.\n",
    "supporting": [
      "h_wrangling_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}