{
  "hash": "35b58b1df68c302b38bfd408d03930db",
  "result": {
    "markdown": "# Several methods for calling different variables\n## Background of the operators\nWhen calling specific variable, list, or object in R, there are three main ways. \nThese include the `$` operator, the `[]` (bracket), and the `%>%` (pipe) operator. \nThese operators work in similar ways in that they allow you to access specific *pieces* of your data frame. \n\nIn this section we will investigate all three. \n\n### The dollar sign: `$` {.unnumbered}\nThis operator is used in R to access the list of a data frame. You can use this operator to access variables, add values or objects, update (e.g., change a class), and delete variables from a data frame.\n\nLet's start by creating a data frame. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nscore <- 1:4 #score column with values of 1-4\n\ninsect <- c('wasp', 'beetle', 'ant', 'TrueBug') #insect column with a list of names \n\nfield <- c('corn', 'beans', 'corn', 'beans') #field column with a list of names\n\nAvg_Weight_mg <- c(2, 7, 0.5, 3) #assigning weight values to each insect\n\nSample_DF <- data.frame(score, insect, field, Avg_Weight_mg) #using the data.frame function to create a date frame with the columns I established above \n\nprint(Sample_DF) #using the print function to view my new data frame\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  score  insect field Avg_Weight_mg\n1     1    wasp  corn           2.0\n2     2  beetle beans           7.0\n3     3     ant  corn           0.5\n4     4 TrueBug beans           3.0\n```\n:::\n:::\n\n\n\nNow that we have our data frame, let's use the `$` operator to investigate our data. \n\nFirst, let's say we want to look at the *insect* column. \nThe `$` operator here pulls out the just the values of this column. \n**Notice**, to use this, we need to specify a source. \nThe source here is '*Sample_DF*'.\nTry this operator out to see which variations of column names will, and will not provide you with an output. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSample_DF$insect #show me the insect column within Sample_DF\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"wasp\"    \"beetle\"  \"ant\"     \"TrueBug\"\n```\n:::\n:::\n\n\n\n\n\nSo, now we can see the functionality of this operator as a means of viewing data. \nLet's now investigate adding a new column to this existing *Sample_DF.* \n\nIn this example, we will be adding a column to specify whether the insect was an adult, or not. \nWe will do this by adding our new object name following our source, *Sample_DF*, and then specifying the values of this column. \n*Remember*, we need to have a source data frame when we use this operator. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSample_DF$adult <- c('yes', 'no', 'no', 'yes') #naming a new column IN Sample_DF with the values within c()\n\nprint(Sample_DF) #printing this updated df\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  score  insect field Avg_Weight_mg adult\n1     1    wasp  corn           2.0   yes\n2     2  beetle beans           7.0    no\n3     3     ant  corn           0.5    no\n4     4 TrueBug beans           3.0   yes\n```\n:::\n:::\n\n\n\nWe can now see our new column was added to the right-hand side of the existing data frame.\n\nLettuce look at one more example of how we can use this operator. \nHere, we will be changing the *class* of an object within Sample_DF. \n\nIn this example, I want to change the class of *score* from integer, to numeric. \nNotice, I have to call the data source in the beginning to tell R I **do not** want to create a new object, I only want to change my existing data frame. Next, I need to specify the source for the function, **as.numeric**. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSample_DF$score <- as.numeric(Sample_DF$score) #within my df, in the score column, change the class to numerical \n```\n:::\n\n\n\nIf you wanted to create a new object with this change, we can simply change the name of the object. \n\nWe can do this, like so. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nNew_DF <- as.numeric(Sample_DF$score) #within a new df, in the score column, change the class to numerical\n\nprint(New_DF) #show me the new df\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4\n```\n:::\n:::\n\n\n\nNotice here, the new object **only** houses the values from the *score* column. \n\n### Single dimension square bois: `[]` {.unnumbered}\nBrackets `[]`, in R, work similarly to that of the dollar sign (`$`).\nBrackets are especially useful when we want to extract single elements from an object. \nLet's start by creating a simple, single dimension vector. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#ceating a numeric vector\nVector_One <- c(1,2,3,4,5,6)\n```\n:::\n\n\n\nNow, let's pull some stoof out. \nIn this example, I am going to pull out several individual values from the vector we just created. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nVector_One[1] #extracting the first value of the data set \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\nVector_One[3] #extracting the third value of the data set \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n\n\nNow that we have extracted individual values, let's pull several out at once. \nNotice that the syntax has changed a bit. \nWe now **must** tell R that we want to combine the three values into one output. \nThis is done by adding, *c(1,2,3)*, within our brackets\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nVector_One[c(1,2,3)] #extracting the first, second, and third value of the data set\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\n```\n:::\n:::\n\n\n\nThe next step is to have R to pull values out based on a command. \nIn the following example, we will use some of the [logic commands](lesson04.qmd) we covered earlier. \n\nLet's say I want to see all of the values in this data set that are above the number 3. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nVector_One[Vector_One > 3] #extracting values greater than 3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4 5 6\n```\n:::\n:::\n\n\n\nWe can repeat this step with any logical operator we would like. \n\nFor example.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nVector_One[Vector_One >= 2] #extracting values greater than or equal to 2\n\nVector_One[Vector_One != 2] #extracting values that do not equal 2\n```\n:::\n\n\n\n### Multiple dimension square bois: `[]` {.unnumbered}\nNow that we can see how to use the brackets when looking for single objects (like a simple vector), let's start to look at the use of brackets with an increase in dimensions. \nMultiple dimensions come into play when we are investigating a full data frame or matrix. \nIn this section, we will be looking at the Sample_DF data frame we created above. \n\nWithin the bracket are assigned values. \nBy this, I mean, depending on the *location* of the number within the bracket, the location that information is pulled from will change. \nThe assigned locations are **[row, column]**\n\nFor example, if we were to run **[1,2]**, our output would be the value in the *first* row and *second* column.\n\nIn this example, we will pull out the values from the first row, and second column. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSample_DF[1,2] #extracting values from row 1 and column 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"wasp\"\n```\n:::\n:::\n\n\n\nNext, let's investigate what happens when we leave one of the 'values' blank. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSample_DF[,2] #extracting values from all rows and the second column\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"wasp\"    \"beetle\"  \"ant\"     \"TrueBug\"\n```\n:::\n:::\n\n\n\nWhat we see here is that R gave us the values from all rows, but just the second column. \n\nWe can use the same method if we want to view information from all one row, but *all* columns. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSample_DF[1,] #extracting values from row 1, and all columns \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  score insect field Avg_Weight_mg adult\n1     1   wasp  corn             2   yes\n```\n:::\n:::\n\n\n\nIn the next example, we will investigate how to *exclude* information. \nLet's say we want to view the whole data frame except for the values of row 1. \nThis is done by using, *-1*, in the row value of the brackets. \n\nIn this example, I am telling R to exclude all values of row 1 from the output. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSample_DF[-1,] #extracting all values, except for row 1 information\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  score  insect field Avg_Weight_mg adult\n2     2  beetle beans           7.0    no\n3     3     ant  corn           0.5    no\n4     4 TrueBug beans           3.0   yes\n```\n:::\n:::\n\n\n\nIn our last example of the bracket, we will extract information from a specified column, but all rows. \nTo do this, we will continue to leave the row value blank, but add in the exact name of the column we seek to view. \n\nLet's take a look at the 'insect' column. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSample_DF[, \"insect\"] #extracting values from all rows, but just the insect column\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"wasp\"    \"beetle\"  \"ant\"     \"TrueBug\"\n```\n:::\n:::\n\n\n\nOur output shows us all of the values within the *insect* column. \n\n### Last but not least, the pipe: `%>%` {.unnumbered}\nFor the sake of not working too far ahead, I will not include many examples here.\nIn the [data wrangling](lesson07.qmd) section, I will be *exclusively* using the pipe operator. \nPlease see that section for working examples of the pipe operator. \n\nSO. \nWe have investigated, and worked through, the dollar sign operator and brackets for pulling out specific elements. \nThese methods are certainly effective, but as we start to work through larger data sets of raw data, there may be many changes we need to apply.\n\nTo accomplish this, we could write out a new command line for each iteration, OR, we can 'pipe' several commands into one operation. \nThis processing of piping *links* all of our changes to one command, allowing for efficiency and easy error-tracking. \nTo reiterate, this task is the *chaining* of arguments into one command.\n\nThis operator, the pipe `%>%`, is arguably one of the most important operators in data wrangling and processing. \n\nRory Spanton, with *Toward Data Science*, explains this process well, \"To visualize this process, imagine a factory with different machines placed along a conveyor belt. Each machine is a function that performs a stage of our analysis, like filtering or transforming data. The pipe therefore works like a conveyor belt, transporting the output of one machine to another for further processing.\" \n\nHere I will write out two examples. \nWithin these examples, I will be creating [functions](lesson05.qmd) and then running them sequentially both with, and without the pipe operator.\nWe **will** cover writing functions in the future. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# starting with creating three separate functions \n\n# a function to add two values\nadd <- function(x,y) {\n  return(x+y)\n}\n\n# a function to multiply two values\nmul <- function(x,y) {\n  return(x*y)\n}\n\n# a function to divide two values\ndiv <- function(x,y) {\n  return(x/y)\n}\n```\n:::\n\n\n\nNow that we have our functions created, let's put them to work in the *long form*. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# I am now calling each function sequentially \n\nresult_1 <- add(2,4) # applying my add function to two values (x,y)\n\nresult_2 <- mul(result_1, 5) # applying my mul function to the results from the add function (x) and a new value of 5 (y)\n\nresult_3 <- div(result_2, 6) # applying my div function to the results from the mul function (x) and a new value of 6 (y)\n\nprint(result_3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n:::\n\n\n\nAs we can see, this method is effective. \nBut, where it falters, is that we must save each iteration and then input that object name into the next function. \nWhile this example is simple, we can imagine how with an increase in the complexity of our functions and sequential manipulations, this can become an overwhelming method.\n\nLet's now look at the same sequence of functions, but this time using the pipe operator. \n\nFirst, we will need to load in the **dplyr** package to use the pipe operator. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr) #loading the dplyr package\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# piping my three functions together \nresults <- add(2,4) %>% # adding 2 and 4 with the add function \n  mul(5) %>% # chaining the results from add into the mul function\n  div(6) #chaining the results from the mul function into the div function\n\nprint(results) #printing the results \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n:::\n\n\n\n**We got the same output! **\nAs we can see, this method is both cleaner (regarding your environment and saving objects over and over) and safer (with regard to errors) than the sequential example. \n\n### The results, explained {.unnumbered}\n\nContinuing to follow Rory's brilliant synthesis of this operator, I will use their example here. \nLet's think of `%>%` as the word '*then*'. \n\nLet's now write out the same piping example. \n\n- The results from this chain will be named \"*results*\", \n\n  - I will be **adding** the numbers 2 and 4 together, *THEN*\n  \n  - I will **multiply** the results from the addition by 5, *THEN*\n  \n  - I will **divide** the results from the multiplication by 6\n\nAs we can see, this operator acts as a *link in the chain* which holds the whole argument together, allowing it to act as one command. \nThe pipe operator is an excellent addition your coding repertoire when you would like to eliminate the saving of multiple objects with each iterative change, lower the risk of an error occurring within the multiple changes, and allow for a cleaner, more palatable, R script. ",
    "supporting": [
      "e_CallingVariables_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}