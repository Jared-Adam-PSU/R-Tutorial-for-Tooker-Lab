{
  "hash": "c9f4de61916de621078914da294f66e4",
  "result": {
    "markdown": "# Coding etiquette\n## How to write code that is clean, clear, and reproducible \n### Naming new objects in R {.unnumbered}\nFirst, and foremost, we should investigate how to name new objects within R. \nThere are two methods to complete this task. \nThese include the equals sign, `=`, and the carrot jawn, `<-`. \n\nFor example, the output of these lines will be identical. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata = c(1,2,3) #new object with equals sign\n\ndata <- c(1,2,3) #new object with carrot jawn\n```\n:::\n\n\nWhile these *are* the same, what we recommend is using the carrot method (`<-`). \nThis is because many functions require the use of `=` within code (this will come up in the future). \nFor this reason, we find it best to utilize the carrot *whenever* you change the name of an object, or add a new object. \n\nIt is important to remember that you can change the time of an object *whenever* you want. \nThis is especially helpful when making changes to our data set. \nWith each iterative change, we can change the name of the object. \nThis will allow us to backtrack to the pevious change in the event we make a mistake. \n\n### Style {.unnumbered}\nCoding, like any other writing type, is dependent upon clear and consistent style. \nAs the tidyverse style guide so eloquently put it, \"Good coding style is like correct punctuation: you can manage without it, butitsuremakesthingseasiertoread.\"\nHere, we can clearly see how a simple phrase becomes exponentially more challenging to read and understand. \nThe same goes for coding. \n\nIt is important to remember that R **cannot** handle spaces between words. \nBecause of this, we must be creative in how we name things.\nIt is a good idea to follow the **BigCamelCase** naming method. \nLet's start by naming a vector. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n#GOOD\nMyNewVector <- c(1,2,3,4,5,6)\n\n#BAD \nmynewvector <- c(7,8,9,10,11,12)\n```\n:::\n\n\nWhile in this example it is fairly easy to read both, we see how the name following the **BigCamelCase** format is easier to follow.\n\nLet's look at another example of naming, this time getting more specific with our vector name. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n#GOOD\nSlugDensityData_Spring2023 <- c(1,3,5,7)\n\n#BAD\nslugdensitydataspring2023 <- c(2,4,6,8)\n```\n:::\n\n\nI incorporated an underscore in the first name to make it even more distinct. We can clearly see now with increasing complexity of our names, the first is much easier to read.  \n\n### Annotations {.unnumbered}\nWhen taking notes in a lecture, do you think it wise to take poorly written and hard to understand notes? \nOr, would we rather take clear, concise, and methodical notes to ensure we can return to them and understand exactly what the lecture was about? \nIf you choose the former, then please, continue reading. \n\nAnnotation, like note taking, is very important within our code. \nWe must be able to return to each line and know exactly what we did and why we did it. \nAlong with this, if we wish to share this code with anyone, they too must be able to understand the methodology without needing you by their side. \nThe habit of good code annotation is one that should be adopted immediately and practiced throughout the duration of your programming days. \n\nLet's look at some examples of both good, and bad annotations. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n#GOOD\n##\n#I am creating a vector to practice running different functions \n\nPracticeVector <- c(11,3,4,5,6,7)\n\n#Trying out the mean function here\nmean(PracticeVector)\n#This works. I will leave this code here to reference in the future\n##\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#BAD\npracticevector <- c(11,2,3,4,5,11,2)\nmean(practicevector)\n```\n:::\n\n\nWhile these examples are very simple in their nature, we can imagine how scrolling through 500+ lines of un-annotated code can be a nightmare. \nAlong with this, to reiterate my naming point, we can see how with poor naming practices and a lack of annotation, the bad example is doubly hard to follow.\n\nAlong with annotating what you are doing, it can also be helpful to write out your thought process for an action. \nLet's say you are writing code for a project on a Friday, and since you are great at managing your workload, you plan to not work this weekend.\nWhen Monday rolls around, you open your R script up and have completely forgotten why you were running a specific test or structuring your code a specific way. \n\nWith proper annotation, this hiccup can be avoided. \n\nLet's take a look at some examples.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#GOOD\n## \n#I am trying to create a fake data set to practice some functions on \n#Not to be used for analyses, simply for me\n\nbugs <- data.frame( #naming this 'bugs' and using the data.frame function to build this\n  spiders = rnorm(200), #naming this column 'spiders' and using the rnorm function. This function builds a column with a default mean of 0 and a standard deviation of 1. This column will have 200 values.\n  beetles = rnorm(250), #Same as above, but with 250 values\n  wasps = rnorm(1000) #Same as above, but with 1000 values\n)\n##\n```\n:::\n\n\nIn this example, I clearly noted what I was doing and why I was doing it. For my sake, I can return to this easily. \nIf someone else was to come upon this, they too would be able to understand what my process was. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n#BAD\nnotbugs <- data.frame(\n  clover = rnorm(200),\n  shrubberies = rnorm(200),\n  elderberry = rnorm(2000)\n)\n```\n:::\n\n\nIn this example, it is unclear what the purpose of this data set is. Along with that, if someone is not familiar with this script, they may find it very challenging to follow.\n",
    "supporting": [
      "g_etiquette_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}